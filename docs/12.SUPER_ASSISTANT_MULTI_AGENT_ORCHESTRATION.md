# 超級管家 Multi-Agent 調度架構升級規劃

> **核心目標**：把事情做對，正確優先於快速。
> 
> **版本**：v1.0  
> **建立日期**：2026-01-19  
> **狀態**：規劃中

---

## 一、問題背景與動機

### 1.1 當前問題

1. **嚴重幻覺**：超級管家與企業參謀無法準確回答特定部門的資料查詢（如「財務部最新檔案」），因為它們使用全域搜尋，被海量雜訊淹沒。
2. **能力分散**：各專用 Agent 擁有精準的知識庫存取能力，但超級管家無法調用它們。
3. **使用者困惑**：使用者不知道該找誰問問題，期望有一個「萬能窗口」。

### 1.2 目標願景

建立一個 **「指揮官型超級管家」**：
- 它不是「萬能博士」，而是「知人善任的主管」。
- 遇到專業問題，它會判斷並呼叫對應的專家 Agent。
- 取得專家回答後，確認正確性，再轉述給使用者。
- 使用者只需對超級管家說話，無需知道系統內有哪些 Agent。

---

## 二、架構設計

### 2.1 核心設計原則

| 原則 | 說明 |
|------|------|
| **正確性優先** | 寧可多花 3 秒取得正確答案，也不要秒回但胡說八道。 |
| **階層式調度** | 超級管家是 L0 指揮官，專用 Agent 是 L1 專家。 |
| **能力隔離** | 超級管家不直接掛載所有工具，而是透過調度間接使用。 |
| **權限傳遞** | 調用專家時繼承使用者既有權限，確保資料安全。 |

### 2.2 系統架構圖

```
┌─────────────────────────────────────────────────────────────────┐
│                        使用者介面層                              │
│    ┌─────────┐    ┌─────────┐    ┌─────────┐                    │
│    │  Web    │    │  LINE   │    │  Voice  │                    │
│    └────┬────┘    └────┬────┘    └────┬────┘                    │
└─────────┼──────────────┼──────────────┼─────────────────────────┘
          │              │              │
          ▼              ▼              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Unified Gateway                              │
└─────────────────────────┬───────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                 L0: 超級管家 (Orchestrator)                      │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  核心能力：                                                 │ │
│  │  1. 意圖識別與路由決策                                      │ │
│  │  2. Agent 調度 (Delegation Tool)                           │ │
│  │  3. 基本知識搜尋 (全域概覽)                                 │ │
│  │  4. 行事曆管理 (系統級 API)                                 │ │
│  │  5. 回應整合與品質把關                                      │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
                          │ 調度呼叫
          ┌───────────────┼───────────────┐
          ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ L1: 財務 Agent  │ │ L1: 人資 Agent  │ │ L1: 法務 Agent  │
│                 │ │                 │ │                 │
│ MCP: 財務系統   │ │ MCP: 員工資料   │ │ Skill: 合約審查 │
│ Skill: 報表分析 │ │ Skill: 假勤查詢 │ │ 知識: 法規庫    │
│ 知識: 財務庫    │ │ 知識: HR 政策   │ │                 │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

### 2.3 MCP / Skills 掛載策略

**關鍵決策：超級管家是否應直接掛載所有 MCP / Skills？**

**答案：否。應採階層式掛載。**

| 掛載方式 | 優點 | 缺點 |
|----------|------|------|
| **全部掛載** | 單一入口 | 權限混亂、Token 爆炸、判斷失準 |
| **階層掛載 ✅** | 權限隔離、成本可控、責任清晰 | 需要調度機制 |

**掛載策略**：

| 層級 | 角色 | 掛載能力 |
|------|------|----------|
| **L0** | 超級管家 | Agent 調度工具、全域知識搜尋、行事曆 API、Email 發送 |
| **L1** | 專用 Agent | 各領域專屬 MCP / Skills / 知識庫 |

---

## 三、技術落地方案

### 3.1 Phase 1：Agent 調度基礎設施

#### 3.1.1 建立 Agent 列表 API

**目的**：讓超級管家知道系統內有哪些專家可用。

**檔案**：`app/api/agents/available/route.ts`

```typescript
/**
 * GET /api/agents/available
 * 取得超級管家可調度的 Agent 列表
 */
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET() {
  const supabase = await createClient();
  
  // 取得所有啟用的 Agent（排除超級管家自己）
  const { data: agents, error } = await supabase
    .from('agents')
    .select('id, name, description, department_id')
    .eq('is_active', true)
    .neq('name', '超級管家'); // 排除自己
  
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  
  // 格式化為調度用途
  const availableAgents = agents.map(agent => ({
    id: agent.id,
    name: agent.name,
    description: agent.description,
    specialization: agent.description, // 用於 LLM 判斷
  }));
  
  return NextResponse.json({ agents: availableAgents });
}
```

#### 3.1.2 建立 Agent 調度工具

**目的**：讓超級管家可以像呼叫函式一樣呼叫其他 Agent。

**檔案**：`lib/super-assistant/tools/agent-delegation.ts`

```typescript
/**
 * Agent Delegation Tool
 * 超級管家調度專用 Agent 的核心工具
 */

import { ToolExecutionResult } from '../tools';

export interface AgentDelegationParams {
  targetAgentId: string;
  query: string;
  userId: string;
  sessionContext?: string; // 對話脈絡摘要
}

export interface DelegationResult {
  success: boolean;
  agentName: string;
  response: string;
  confidence?: number;
  sources?: string[];
}

export class AgentDelegationTool {
  
  /**
   * 調度指定 Agent 處理查詢
   */
  async execute(params: AgentDelegationParams): Promise<ToolExecutionResult> {
    const { targetAgentId, query, userId, sessionContext } = params;
    
    try {
      // 1. 建立內部 API 請求
      const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // 傳遞原始使用者身份以繼承權限
          'X-Delegated-User-Id': userId,
        },
        body: JSON.stringify({
          agent_id: targetAgentId,
          message: this.buildDelegatedQuery(query, sessionContext),
          is_delegation: true, // 標記為調度請求
        }),
      });
      
      if (!response.ok) {
        return {
          success: false,
          error: `Agent 調度失敗：${response.status}`,
        };
      }
      
      // 2. 處理 SSE 串流回應，收集完整內容
      const fullResponse = await this.collectStreamResponse(response);
      
      // 3. 解析回應中的 metadata
      const { text, confidence, citations } = this.parseResponse(fullResponse);
      
      return {
        success: true,
        data: {
          response: text,
          confidence: confidence,
          sources: citations,
        } as DelegationResult,
      };
      
    } catch (error) {
      console.error('[AgentDelegation] Error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : '未知錯誤',
      };
    }
  }
  
  /**
   * 建構調度用查詢（加入脈絡）
   */
  private buildDelegatedQuery(query: string, context?: string): string {
    if (!context) return query;
    return `${context}\n\n使用者問題：${query}`;
  }
  
  /**
   * 收集 SSE 串流回應
   */
  private async collectStreamResponse(response: Response): Promise<string> {
    const reader = response.body?.getReader();
    if (!reader) return '';
    
    const decoder = new TextDecoder();
    let fullText = '';
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n\n');
      
      for (const line of lines) {
        if (line.startsWith('data: ') && !line.includes('[DONE]')) {
          try {
            const data = JSON.parse(line.replace('data: ', ''));
            if (data.text) fullText += data.text;
          } catch {
            // 忽略解析錯誤
          }
        }
      }
    }
    
    return fullText;
  }
  
  /**
   * 解析回應內容
   */
  private parseResponse(text: string): { 
    text: string; 
    confidence?: number; 
    citations?: string[]; 
  } {
    // 基本實作，未來可增強
    return { text, confidence: undefined, citations: undefined };
  }
}
```

### 3.2 Phase 2：Orchestrator 智慧路由

#### 3.2.1 改造 Orchestrator 意圖識別

**目的**：讓超級管家能判斷「自己處理」還是「委派專家」。

**修改檔案**：`lib/super-assistant/orchestrator.ts`

```typescript
// 新增的 Intent Types
export type IntentType =
  | 'query'
  | 'action'
  | 'scheduled'
  | 'greeting'
  | 'delegate' // 新增：需要調度專家
  | 'unknown';

export interface IntentResult {
  type: IntentType;
  confidence: number;
  targetAgentId?: string;     // 若為 delegate，指定目標 Agent
  targetAgentName?: string;   // 人類可讀名稱
  reason?: string;            // 路由決策原因
  entities?: Record<string, string | string[]>;
  suggestedTools?: string[];
}

/**
 * 使用 LLM 進行智慧路由判斷
 */
private async identifyIntentWithLLM(
  message: UnifiedMessage,
  availableAgents: Array<{ id: string; name: string; description: string }>
): Promise<IntentResult> {
  
  const { generateContent } = await import('@/lib/gemini/client');
  
  const agentList = availableAgents
    .map(a => `- ${a.name} (ID: ${a.id}): ${a.description}`)
    .join('\n');
  
  const prompt = `你是企業 AI 系統的調度中心。根據使用者問題，決定該如何處理。

## 可用的專家 Agent：
${agentList}

## 你自己（超級管家）擅長：
- 一般性寒暄與問候
- 行程安排與會議管理
- 跨部門的概括性問題
- 系統操作指引

## 使用者問題：
${message.content.text}

## 決策規則：
1. 若問題明確涉及特定部門專業（如財務報表、人事假勤、法律合約），選擇 "delegate" 並指定對應專家。
2. 若問題是一般性問候或你能直接回答的，選擇 "self"。
3. 若不確定，優先選擇 "delegate" 找最相關的專家（正確優先於速度）。

請回覆以下 JSON 格式：
{
  "action": "delegate" | "self",
  "targetAgentId": "若 delegate，填入 Agent ID",
  "targetAgentName": "若 delegate，填入 Agent 名稱",
  "reason": "簡短說明決策原因"
}`;

  try {
    const response = await generateContent('gemini-2.0-flash', prompt);
    const decision = JSON.parse(response);
    
    if (decision.action === 'delegate') {
      return {
        type: 'delegate',
        confidence: 0.9,
        targetAgentId: decision.targetAgentId,
        targetAgentName: decision.targetAgentName,
        reason: decision.reason,
      };
    }
    
    // 自己處理，繼續使用既有邏輯判斷細分類型
    return this.identifyIntent(message);
    
  } catch (error) {
    console.error('[Orchestrator] LLM routing error:', error);
    // 降級：使用關鍵字規則
    return this.identifyIntent(message);
  }
}
```

#### 3.2.2 改造 processMessage 主流程

```typescript
/**
 * 處理統一訊息並產生回應（支援調度）
 */
async processMessage(message: UnifiedMessage): Promise<UnifiedResponse> {
  
  // 1. 取得可用 Agent 列表
  const availableAgents = await this.fetchAvailableAgents();
  
  // 2. 智慧路由判斷
  const intent = await this.identifyIntentWithLLM(message, availableAgents);
  
  // 3. 若需要調度專家
  if (intent.type === 'delegate' && intent.targetAgentId) {
    return this.handleDelegation(message, intent);
  }
  
  // 4. 其他情況維持原有邏輯
  switch (intent.type) {
    case 'greeting':
      return this.handleGreeting(message);
    case 'query':
      return this.handleQuery(message, intent);
    case 'action':
      return this.handleAction(message, intent);
    case 'scheduled':
      return this.handleScheduled(message, intent);
    default:
      return this.handleUnknown(message);
  }
}

/**
 * 處理調度請求
 */
private async handleDelegation(
  message: UnifiedMessage,
  intent: IntentResult
): Promise<UnifiedResponse> {
  
  const delegationTool = new AgentDelegationTool();
  
  // 執行調度
  const result = await delegationTool.execute({
    targetAgentId: intent.targetAgentId!,
    query: message.content.text || '',
    userId: this._config.systemUserId || '',
  });
  
  if (!result.success) {
    return {
      content: {
        type: 'text',
        text: `抱歉，我嘗試請教 ${intent.targetAgentName}，但遇到了一點問題。讓我試著自己回答...\n\n（系統提示：${result.error}）`,
      },
    };
  }
  
  const delegationData = result.data as DelegationResult;
  
  // 整合專家回答
  return {
    content: {
      type: 'text',
      text: delegationData.response,
    },
    metadata: {
      delegatedTo: intent.targetAgentName,
      confidence: delegationData.confidence,
      sources: delegationData.sources,
    },
  };
}

/**
 * 取得可用 Agent 列表
 */
private async fetchAvailableAgents(): Promise<Array<{
  id: string;
  name: string;
  description: string;
}>> {
  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_APP_URL}/api/agents/available`
    );
    if (!response.ok) return [];
    const data = await response.json();
    return data.agents || [];
  } catch {
    return [];
  }
}
```

### 3.3 Phase 3：品質把關與降級機制

#### 3.3.1 回應驗證

```typescript
/**
 * 驗證專家回應的品質
 */
private async validateDelegationResponse(
  originalQuery: string,
  expertResponse: string
): Promise<{ isValid: boolean; issue?: string }> {
  
  const { generateContent } = await import('@/lib/gemini/client');
  
  const prompt = `判斷以下回答是否合理回應了使用者問題：

使用者問題：${originalQuery}

專家回答：${expertResponse}

請回覆 JSON：
{
  "isValid": true/false,
  "issue": "若不合理，簡述問題"
}`;

  try {
    const response = await generateContent('gemini-2.0-flash', prompt);
    return JSON.parse(response);
  } catch {
    return { isValid: true }; // 預設信任
  }
}
```

#### 3.3.2 降級與重試機制

```typescript
/**
 * 處理調度失敗的降級策略
 */
private async handleDelegationWithFallback(
  message: UnifiedMessage,
  intent: IntentResult
): Promise<UnifiedResponse> {
  
  // 第一次嘗試
  let result = await this.handleDelegation(message, intent);
  
  // 驗證回應
  const validation = await this.validateDelegationResponse(
    message.content.text || '',
    result.content.text || ''
  );
  
  if (!validation.isValid) {
    // 降級策略 1：嘗試其他相關 Agent
    // 降級策略 2：自己嘗試回答但標記低信心
    // 降級策略 3：坦誠告知無法回答
    
    return {
      content: {
        type: 'text',
        text: `我詢問了 ${intent.targetAgentName}，但回答似乎不太完整。\n\n根據我目前掌握的資訊，我無法確定完整答案。建議您直接到相關部門確認，或提供更多細節讓我再試一次。`,
      },
      metadata: {
        confidence: 0.3,
        needsReview: true,
      },
    };
  }
  
  return result;
}
```

---

## 四、資料庫變更

### 4.1 新增欄位

無需新增資料表，但建議在 `agents` 表新增欄位：

```sql
-- 標記 Agent 是否可被調度
ALTER TABLE agents ADD COLUMN is_delegatable BOOLEAN DEFAULT true;

-- Agent 專長標籤（用於智慧路由）
ALTER TABLE agents ADD COLUMN specialization_tags TEXT[];

-- 範例：
-- UPDATE agents SET specialization_tags = ARRAY['財務', '報表', '會計'] WHERE name = '財務部 Agent';
```

### 4.2 調度歷史記錄

```sql
-- 新增調度歷史表（可選，用於分析與優化）
CREATE TABLE agent_delegations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  orchestrator_session_id UUID REFERENCES chat_sessions(id),
  source_agent_id UUID REFERENCES agents(id), -- 超級管家
  target_agent_id UUID REFERENCES agents(id), -- 被調度的專家
  query TEXT NOT NULL,
  response TEXT,
  was_successful BOOLEAN DEFAULT true,
  routing_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 五、執行計畫

### 5.1 優先順序與時程

| 優先級 | 階段 | 項目 | 預估工時 | 負責 |
|--------|------|------|----------|------|
| **P0** | Phase 1 | Agent 列表 API | 1hr | Backend |
| **P0** | Phase 1 | Agent Delegation Tool | 3hr | Backend |
| **P0** | Phase 2 | Orchestrator 智慧路由 | 4hr | Backend |
| **P1** | Phase 2 | 整合測試與除錯 | 2hr | Full-stack |
| **P1** | Phase 3 | 回應驗證機制 | 2hr | Backend |
| **P2** | Phase 3 | 降級與重試機制 | 2hr | Backend |
| **P2** | 可選 | 調度歷史記錄 | 1hr | Backend |

**總計**：約 15 工作小時

### 5.2 測試驗收標準

1. **正確性測試**：
   - 詢問「財務部最新檔案」→ 超級管家調度財務 Agent → 正確回答 ✅
   - 詢問「人資假勤規定」→ 超級管家調度人資 Agent → 正確回答 ✅

2. **降級測試**：
   - 調度失敗時 → 顯示友善錯誤訊息 ✅
   - 回答品質不佳時 → 標記需人工審查 ✅

3. **權限測試**：
   - 無財務權限的使用者 → 調度財務 Agent 時被擋下 ✅

---

## 六、風險與緩解

| 風險 | 影響 | 緩解措施 |
|------|------|----------|
| 路由判斷錯誤 | 問錯人 | 加入驗證機制，可重試或降級 |
| 延遲增加 | 使用者體驗 | 加入「正在詢問專家...」的即時反饋 |
| Token 成本 | 營運成本 | 使用較快的模型做路由，專家用完整模型 |
| 循環調度 | 系統錯誤 | 加入調度深度限制（最多 2 層） |

---

## 七、未來擴展

1. **A2A (Agent-to-Agent) 協作**：多個專家 Agent 協同完成複雜任務。
2. **學習式路由**：根據歷史調度成功率自動優化路由策略。
3. **排程調度**：「每週一早上請財務 Agent 生成週報告」。
4. **主動通知**：專家 Agent 發現異常時，主動通知超級管家。

---

## 八、結論

透過 Multi-Agent Orchestration 架構，超級管家將從「什麼都想自己答」轉型為「知人善任的指揮官」。這是解決幻覺問題的根本解法，也是建構企業級 AI 協作系統的必經之路。

**核心信念**：正確性 > 速度。使用者願意多等 3 秒，換取一個可信賴的答案。
