# EAKAP é€²éšçŸ¥è­˜æ¶æ§‹ç³»çµ±è¨­è¨ˆ
**ç‰ˆæœ¬ï¼š** v3.0  
**å»ºç«‹æ—¥æœŸï¼š** 2026-01-01  
**æœ€å¾Œæ›´æ–°ï¼š** 2026-01-05  
**è¨­è¨ˆç›®æ¨™ï¼š** å»ºç«‹ä¸€å¥—æ¥µåº¦å°ˆæ¥­ã€å…·æŠ€è¡“èˆ‡å…§å®¹é–€æª»çš„çŸ¥è­˜æ¶æ§‹ç³»çµ±ï¼Œè®“ AI Agent èƒ½ç²¾æº–è§£è®€èˆ‡é‹ç”¨ä¼æ¥­çŸ¥è­˜

---

## ğŸ“‹ åŸ·è¡Œæ‘˜è¦

### æ ¸å¿ƒåƒ¹å€¼ä¸»å¼µ

æœ¬ç³»çµ±ä¸åƒ…åƒ…æ˜¯æ–‡ä»¶åˆ†é¡ç³»çµ±ï¼Œè€Œæ˜¯ä¸€å¥—**ã€Œèªç¾©çŸ¥è­˜æ¶æ§‹å¼•æ“ã€**ï¼Œå…·å‚™ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

#### åŸºç¤èƒ½åŠ›ï¼ˆv2.0ï¼‰
1. **å¤šç¶­åº¦çŸ¥è­˜ç´¢å¼•**ï¼šè¶…è¶Šå‚³çµ±åˆ†é¡ï¼Œå»ºç«‹èªç¾©ã€æ™‚åºã€é—œè¯ã€æ¬Šé‡å››ç¶­ç´¢å¼•
2. **æ™ºèƒ½çŸ¥è­˜è·¯ç”±**ï¼šAgent å»ºç«‹æ™‚è‡ªå‹•é¸æ“‡æœ€ç›¸é—œçš„çŸ¥è­˜ä¾†æº
3. **çŸ¥è­˜å“è³ªè©•ä¼°**ï¼šAI è‡ªå‹•è©•ä¼°çŸ¥è­˜çš„å®Œæ•´æ€§ã€æº–ç¢ºæ€§ã€æ™‚æ•ˆæ€§
4. **èªç¾©çŸ¥è­˜åœ–è­œ**ï¼šå»ºç«‹çŸ¥è­˜ä¹‹é–“çš„èªç¾©é—œè¯ï¼Œæ”¯æ´æ¨ç†èˆ‡ç™¼ç¾
5. **çŸ¥è­˜æ¼”åŒ–è¿½è¹¤**ï¼šè¿½è¹¤çŸ¥è­˜çš„ç‰ˆæœ¬æ¼”é€²èˆ‡ä¾è³´é—œä¿‚

#### é€²éšèƒ½åŠ›ï¼ˆv3.0 æ–°å¢ï¼‰
6. **çŸ¥è­˜è¡°æ¸›æ¨¡å‹**ï¼šä¾çŸ¥è­˜é¡å‹è‡ªå‹•è¨ˆç®—ã€ŒçŸ¥è­˜ä¿é®®æœŸã€ï¼Œé¿å…ä½¿ç”¨éæ™‚çŸ¥è­˜
7. **åé¥‹å­¸ç¿’è¿´è·¯**ï¼šå¾ Agent ä½¿ç”¨çµæœå­¸ç¿’ï¼ŒæŒçºŒå„ªåŒ–çŸ¥è­˜å“è³ªè©•åˆ†
8. **çŸ¥è­˜ç¢ç‰‡èšåˆ**ï¼šè‡ªå‹•ç™¼ç¾ä¸¦æ•´åˆåˆ†æ•£çš„çŸ¥è­˜ç¢ç‰‡ï¼Œå»ºæ§‹å®Œæ•´çŸ¥è­˜å–®å…ƒ
9. **é«˜æ•ˆèƒ½èªç¾©æœå°‹**ï¼šä½¿ç”¨ ANN æ¼”ç®—æ³•å¯¦ç¾è¬ç´šæ–‡ä»¶çš„å³æ™‚èªç¾©æœå°‹
10. **ä¸»å‹•æ¨é€æ©Ÿåˆ¶**ï¼šçŸ¥è­˜è®Šæ›´æ™‚ä¸»å‹•é€šçŸ¥ç›¸é—œ Agentï¼Œé¿å…ä½¿ç”¨éæ™‚çŸ¥è­˜

### æŠ€è¡“é–€æª»

- **è¤‡é›œåº¦é–€æª»**ï¼šå¤šå±¤æ¬¡ AI æ¨ç†ã€èªç¾©åˆ†æã€é—œè¯è¨ˆç®—
- **å…§å®¹é–€æª»**ï¼šåŸºæ–¼ DIKW ç†è«–ã€çŸ¥è­˜ç®¡ç†æœ€ä½³å¯¦è¸ã€ä¼æ¥­æ²»ç†æ¨™æº–
- **å¯¦ä½œé–€æª»**ï¼šéœ€è¦æ·±åº¦ç†è§£ AI Agent é‹ä½œæ©Ÿåˆ¶ã€çŸ¥è­˜åœ–è­œæŠ€è¡“ã€èªç¾©æœå°‹

---

## ğŸ—ï¸ ç³»çµ±æ¶æ§‹è¨­è¨ˆ

### 1. å¤šç¶­åº¦çŸ¥è­˜ç´¢å¼•ç³»çµ±ï¼ˆMulti-dimensional Knowledge Indexï¼‰

#### 1.1 å››ç¶­ç´¢å¼•æ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å¤šç¶­åº¦çŸ¥è­˜ç´¢å¼•ç³»çµ± (MDKI)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ èªç¾©ç¶­åº¦     â”‚  â”‚ æ™‚åºç¶­åº¦     â”‚  â”‚ é—œè¯ç¶­åº¦     â”‚ â”‚
â”‚  â”‚ Semantic     â”‚  â”‚ Temporal     â”‚  â”‚ Relational   â”‚ â”‚
â”‚  â”‚ - Embedding  â”‚  â”‚ - Created    â”‚  â”‚ - Framework  â”‚ â”‚
â”‚  â”‚ - Keywords   â”‚  â”‚ - Updated    â”‚  â”‚ - Dependency â”‚ â”‚
â”‚  â”‚ - Topics     â”‚  â”‚ - ValidUntil â”‚  â”‚ - Hierarchy  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ¬Šé‡ç¶­åº¦     â”‚  â”‚ å“è³ªç¶­åº¦     â”‚  â”‚ å¯ç”¨æ€§ç¶­åº¦   â”‚ â”‚
â”‚  â”‚ Weight       â”‚  â”‚ Quality      â”‚  â”‚ Availability â”‚ â”‚
â”‚  â”‚ - Relevance  â”‚  â”‚ - Completenessâ”‚ â”‚ - Access     â”‚ â”‚
â”‚  â”‚ - Authority  â”‚  â”‚ - Accuracy   â”‚  â”‚ - Status     â”‚ â”‚
â”‚  â”‚ - Usage      â”‚  â”‚ - Freshness   â”‚  â”‚ - Permission â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.2 ç´¢å¼•å¯¦ä½œè¨­è¨ˆ

```typescript
// lib/knowledge/indexing/multi-dimensional-index.ts

/**
 * å¤šç¶­åº¦çŸ¥è­˜ç´¢å¼•
 */
export interface MultiDimensionalKnowledgeIndex {
    // èªç¾©ç¶­åº¦
    semantic: {
        embedding: number[];           // å‘é‡åµŒå…¥ï¼ˆ1536 ç¶­ï¼‰
        keywords: string[];              // é—œéµè©ï¼ˆTF-IDF åŠ æ¬Šï¼‰
        topics: string[];                // ä¸»é¡Œæ¨™ç±¤
        entities: Entity[];              // å¯¦é«”è­˜åˆ¥ï¼ˆäººç‰©ã€çµ„ç¹”ã€ç”¢å“ç­‰ï¼‰
        concepts: Concept[];              // æ¦‚å¿µæå–ï¼ˆæŠ½è±¡æ¦‚å¿µï¼‰
    };
    
    // æ™‚åºç¶­åº¦
    temporal: {
        created_at: string;              // å»ºç«‹æ™‚é–“
        updated_at: string;              // æ›´æ–°æ™‚é–“
        valid_from: string;              // ç”Ÿæ•ˆæ™‚é–“
        valid_until: string | null;      // å¤±æ•ˆæ™‚é–“
        version: string;                 // ç‰ˆæœ¬è™Ÿ
        lifecycle_stage: LifecycleStage; // ç”Ÿå‘½é€±æœŸéšæ®µ
    };
    
    // é—œè¯ç¶­åº¦
    relational: {
        framework_id: string | null;     // æ‰€å±¬çŸ¥è­˜æ¡†æ¶
        instance_id: string | null;      // çŸ¥è­˜å¯¦ä¾‹ ID
        parent_file_id: string | null;   // çˆ¶æª”æ¡ˆï¼ˆè¡ç”Ÿé—œä¿‚ï¼‰
        child_file_ids: string[];        // å­æª”æ¡ˆï¼ˆè¡ç”Ÿé—œä¿‚ï¼‰
        related_file_ids: string[];      // ç›¸é—œæª”æ¡ˆï¼ˆèªç¾©é—œè¯ï¼‰
        dependency_chain: string[];      // ä¾è³´éˆï¼ˆçŸ¥è­˜ä¾è³´ï¼‰
    };
    
    // æ¬Šé‡ç¶­åº¦
    weight: {
        relevance_score: number;          // ç›¸é—œåº¦è©•åˆ†ï¼ˆ0-1ï¼‰
        authority_score: number;         // æ¬Šå¨æ€§è©•åˆ†ï¼ˆ0-1ï¼‰
        usage_frequency: number;         // ä½¿ç”¨é »ç‡
        citation_count: number;         // å¼•ç”¨æ¬¡æ•¸
        agent_usage_count: number;       // Agent ä½¿ç”¨æ¬¡æ•¸
    };
    
    // å“è³ªç¶­åº¦
    quality: {
        completeness_score: number;      // å®Œæ•´æ€§è©•åˆ†ï¼ˆ0-1ï¼‰
        accuracy_score: number;          // æº–ç¢ºæ€§è©•åˆ†ï¼ˆ0-1ï¼‰
        freshness_score: number;         // æ™‚æ•ˆæ€§è©•åˆ†ï¼ˆ0-1ï¼‰
        consistency_score: number;       // ä¸€è‡´æ€§è©•åˆ†ï¼ˆ0-1ï¼‰
        validation_status: ValidationStatus; // é©—è­‰ç‹€æ…‹
    };
    
    // å¯ç”¨æ€§ç¶­åº¦
    availability: {
        access_level: AccessLevel;       // å­˜å–å±¤ç´š
        department_restrictions: string[]; // éƒ¨é–€é™åˆ¶
        tag_restrictions: TagRestriction[]; // æ¨™ç±¤é™åˆ¶
        status: FileStatus;              // æª”æ¡ˆç‹€æ…‹
        dikw_level: DIKWLevel;           // DIKW å±¤ç´š
    };
}
```

### 2. æ™ºèƒ½çŸ¥è­˜è·¯ç”±ç³»çµ±ï¼ˆIntelligent Knowledge Routingï¼‰

#### 2.1 Agent çŸ¥è­˜è·¯ç”±æ¼”ç®—æ³•

ç•¶ Agent å»ºç«‹æ™‚ï¼Œç³»çµ±æœƒè‡ªå‹•é¸æ“‡æœ€ç›¸é—œçš„çŸ¥è­˜ä¾†æºï¼š

```typescript
// lib/knowledge/routing/agent-knowledge-router.ts

/**
 * Agent çŸ¥è­˜è·¯ç”±æ¼”ç®—æ³•
 * 
 * ç›®æ¨™ï¼šæ ¹æ“š Agent çš„ä»»å‹™æè¿°ï¼Œè‡ªå‹•é¸æ“‡æœ€ç›¸é—œçš„çŸ¥è­˜ä¾†æº
 */
export class AgentKnowledgeRouter {
    /**
     * ç‚º Agent é¸æ“‡çŸ¥è­˜ä¾†æº
     * 
     * @param agentDescription Agent ä»»å‹™æè¿°
     * @param agentSkills Agent æŠ€èƒ½åˆ—è¡¨
     * @param departmentId éƒ¨é–€ IDï¼ˆç”¨æ–¼æ¬Šé™éæ¿¾ï¼‰
     * @returns æ¨è–¦çš„çŸ¥è­˜ä¾†æºåˆ—è¡¨ï¼ˆæŒ‰ç›¸é—œåº¦æ’åºï¼‰
     */
    async routeKnowledgeForAgent(
        agentDescription: string,
        agentSkills: AgentSkill[],
        departmentId: string | null
    ): Promise<KnowledgeRoute[]> {
        
        // Step 1: èªç¾©åŒ¹é…ï¼ˆä½¿ç”¨ Embedding ç›¸ä¼¼åº¦ï¼‰
        const semanticMatches = await this.findSemanticMatches(
            agentDescription,
            agentSkills,
            departmentId
        );
        
        // Step 2: æ¡†æ¶åŒ¹é…ï¼ˆæ ¹æ“š Agent Skills åŒ¹é…çŸ¥è­˜æ¡†æ¶ï¼‰
        const frameworkMatches = await this.findFrameworkMatches(
            agentSkills,
            departmentId
        );
        
        // Step 3: DIKW å±¤ç´šéæ¿¾ï¼ˆå„ªå…ˆé¸æ“‡ Knowledge å’Œ Wisdom å±¤ç´šï¼‰
        const dikwFiltered = this.filterByDIKWLevel(
            [...semanticMatches, ...frameworkMatches],
            ['knowledge', 'wisdom'] // å„ªå…ˆå±¤ç´š
        );
        
        // Step 4: å“è³ªéæ¿¾ï¼ˆéæ¿¾ä½å“è³ªçŸ¥è­˜ï¼‰
        const qualityFiltered = this.filterByQuality(
            dikwFiltered,
            { minCompleteness: 0.7, minAccuracy: 0.8 }
        );
        
        // Step 5: æ™‚æ•ˆæ€§éæ¿¾ï¼ˆéæ¿¾éæœŸçŸ¥è­˜ï¼‰
        const temporalFiltered = this.filterByTemporal(
            qualityFiltered,
            { maxAge: 365 } // æœ€å¤š 1 å¹´
        );
        
        // Step 6: æ¬Šé‡æ’åºï¼ˆç¶œåˆç›¸é—œåº¦ã€æ¬Šå¨æ€§ã€ä½¿ç”¨é »ç‡ï¼‰
        const ranked = this.rankByWeight(temporalFiltered, {
            relevanceWeight: 0.4,
            authorityWeight: 0.3,
            usageWeight: 0.3
        });
        
        // Step 7: å¤šæ¨£æ€§å¹³è¡¡ï¼ˆç¢ºä¿çŸ¥è­˜ä¾†æºå¤šæ¨£åŒ–ï¼‰
        const diversified = this.ensureDiversity(ranked, {
            maxPerFramework: 3,      // æ¯å€‹æ¡†æ¶æœ€å¤š 3 å€‹
            maxPerCategory: 5,       // æ¯å€‹é¡åˆ¥æœ€å¤š 5 å€‹
            minTotalSources: 5,      // æœ€å°‘ 5 å€‹ä¾†æº
            maxTotalSources: 20      // æœ€å¤š 20 å€‹ä¾†æº
        });
        
        return diversified;
    }
    
    /**
     * èªç¾©åŒ¹é…ï¼ˆä½¿ç”¨ Embedding ç›¸ä¼¼åº¦ï¼‰
     */
    private async findSemanticMatches(
        description: string,
        skills: AgentSkill[],
        departmentId: string | null
    ): Promise<KnowledgeRoute[]> {
        // 1. ç”Ÿæˆ Agent æè¿°çš„ Embedding
        const agentEmbedding = await generateEmbedding(description);
        
        // 2. æŸ¥è©¢ç›¸ä¼¼åº¦æœ€é«˜çš„çŸ¥è­˜
        const { data: files } = await supabase
            .from('files')
            .select('*, content_embedding, metadata_analysis')
            .eq('gemini_state', 'SYNCED')
            .not('content_embedding', 'is', null);
        
        // 3. è¨ˆç®—ç›¸ä¼¼åº¦
        const matches = files
            .map(file => ({
                file,
                similarity: cosineSimilarity(agentEmbedding, file.content_embedding)
            }))
            .filter(m => m.similarity > 0.7) // ç›¸ä¼¼åº¦é–¾å€¼
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, 20); // Top 20
        
        return matches.map(m => ({
            type: 'file',
            id: m.file.id,
            relevance_score: m.similarity,
            reason: 'èªç¾©ç›¸ä¼¼åº¦é«˜'
        }));
    }
    
    /**
     * æ¡†æ¶åŒ¹é…ï¼ˆæ ¹æ“š Agent Skills åŒ¹é…çŸ¥è­˜æ¡†æ¶ï¼‰
     */
    private async findFrameworkMatches(
        skills: AgentSkill[],
        departmentId: string | null
    ): Promise<KnowledgeRoute[]> {
        // 1. æå–æŠ€èƒ½å°æ‡‰çš„æ¡†æ¶ä»£ç¢¼
        const frameworkCodes = this.extractFrameworkCodes(skills);
        
        // 2. æŸ¥è©¢å°æ‡‰çš„çŸ¥è­˜å¯¦ä¾‹
        const { data: instances } = await supabase
            .from('knowledge_instances')
            .select('*, knowledge_frameworks(code, name)')
            .in('knowledge_frameworks.code', frameworkCodes)
            .gte('completeness', 0.7)  // å®Œæ•´æ€§ >= 70%
            .gte('confidence', 0.8);   // ä¿¡å¿ƒåº¦ >= 80%
        
        return instances.map(inst => ({
            type: 'instance',
            id: inst.id,
            framework_code: inst.knowledge_frameworks.code,
            relevance_score: inst.completeness * inst.confidence,
            reason: `ç¬¦åˆ ${inst.knowledge_frameworks.name} æ¡†æ¶`
        }));
    }
    
    /**
     * DIKW å±¤ç´šéæ¿¾
     */
    private filterByDIKWLevel(
        routes: KnowledgeRoute[],
        preferredLevels: DIKWLevel[]
    ): KnowledgeRoute[] {
        // å„ªå…ˆé¸æ“‡ Knowledge å’Œ Wisdom å±¤ç´š
        const preferred = routes.filter(r => 
            r.dikw_level && preferredLevels.includes(r.dikw_level)
        );
        
        // å¦‚æœå„ªå…ˆå±¤ç´šä¸è¶³ï¼Œå†è£œå…… Information å±¤ç´š
        if (preferred.length < 5) {
            const additional = routes.filter(r => 
                r.dikw_level === 'information' && !preferred.includes(r)
            );
            return [...preferred, ...additional.slice(0, 5 - preferred.length)];
        }
        
        return preferred;
    }
    
    /**
     * å“è³ªéæ¿¾
     */
    private filterByQuality(
        routes: KnowledgeRoute[],
        thresholds: { minCompleteness: number; minAccuracy: number }
    ): KnowledgeRoute[] {
        return routes.filter(r => 
            r.quality.completeness_score >= thresholds.minCompleteness &&
            r.quality.accuracy_score >= thresholds.minAccuracy
        );
    }
    
    /**
     * æ™‚æ•ˆæ€§éæ¿¾
     */
    private filterByTemporal(
        routes: KnowledgeRoute[],
        options: { maxAge: number }
    ): KnowledgeRoute[] {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - options.maxAge);
        
        return routes.filter(r => {
            if (!r.temporal.updated_at) return false;
            const updatedDate = new Date(r.temporal.updated_at);
            return updatedDate >= cutoffDate;
        });
    }
    
    /**
     * æ¬Šé‡æ’åº
     */
    private rankByWeight(
        routes: KnowledgeRoute[],
        weights: { relevanceWeight: number; authorityWeight: number; usageWeight: number }
    ): KnowledgeRoute[] {
        return routes
            .map(r => ({
                ...r,
                composite_score: 
                    r.weight.relevance_score * weights.relevanceWeight +
                    r.weight.authority_score * weights.authorityWeight +
                    (r.weight.usage_frequency / 100) * weights.usageWeight
            }))
            .sort((a, b) => b.composite_score - a.composite_score);
    }
    
    /**
     * å¤šæ¨£æ€§å¹³è¡¡
     */
    private ensureDiversity(
        routes: KnowledgeRoute[],
        options: {
            maxPerFramework: number;
            maxPerCategory: number;
            minTotalSources: number;
            maxTotalSources: number;
        }
    ): KnowledgeRoute[] {
        const frameworkCounts = new Map<string, number>();
        const categoryCounts = new Map<string, number>();
        const result: KnowledgeRoute[] = [];
        
        for (const route of routes) {
            // æª¢æŸ¥æ¡†æ¶é™åˆ¶
            if (route.framework_code) {
                const count = frameworkCounts.get(route.framework_code) || 0;
                if (count >= options.maxPerFramework) continue;
                frameworkCounts.set(route.framework_code, count + 1);
            }
            
            // æª¢æŸ¥é¡åˆ¥é™åˆ¶
            if (route.category_id) {
                const count = categoryCounts.get(route.category_id) || 0;
                if (count >= options.maxPerCategory) continue;
                categoryCounts.set(route.category_id, count + 1);
            }
            
            result.push(route);
            
            if (result.length >= options.maxTotalSources) break;
        }
        
        // ç¢ºä¿æœ€å°‘ä¾†æºæ•¸
        if (result.length < options.minTotalSources) {
            const additional = routes
                .filter(r => !result.includes(r))
                .slice(0, options.minTotalSources - result.length);
            result.push(...additional);
        }
        
        return result;
    }
}
```

### 3. çŸ¥è­˜å“è³ªè©•ä¼°ç³»çµ±ï¼ˆKnowledge Quality Assessmentï¼‰

#### 3.1 å¤šç¶­åº¦å“è³ªè©•ä¼°

```typescript
// lib/knowledge/quality/quality-assessor.ts

/**
 * çŸ¥è­˜å“è³ªè©•ä¼°ç³»çµ±
 * 
 * è‡ªå‹•è©•ä¼°çŸ¥è­˜çš„å®Œæ•´æ€§ã€æº–ç¢ºæ€§ã€æ™‚æ•ˆæ€§ã€ä¸€è‡´æ€§
 */
export class KnowledgeQualityAssessor {
    /**
     * è©•ä¼°çŸ¥è­˜å“è³ª
     */
    async assessQuality(
        fileId: string,
        content: string,
        metadata: any
    ): Promise<QualityAssessment> {
        
        // 1. å®Œæ•´æ€§è©•ä¼°
        const completeness = await this.assessCompleteness(content, metadata);
        
        // 2. æº–ç¢ºæ€§è©•ä¼°
        const accuracy = await this.assessAccuracy(content, metadata);
        
        // 3. æ™‚æ•ˆæ€§è©•ä¼°
        const freshness = await this.assessFreshness(metadata);
        
        // 4. ä¸€è‡´æ€§è©•ä¼°
        const consistency = await this.assessConsistency(content, metadata);
        
        // 5. çµæ§‹åŒ–ç¨‹åº¦è©•ä¼°
        const structure = await this.assessStructure(content);
        
        // 6. ç¶œåˆè©•åˆ†
        const overallScore = this.calculateOverallScore({
            completeness,
            accuracy,
            freshness,
            consistency,
            structure
        });
        
        return {
            completeness,
            accuracy,
            freshness,
            consistency,
            structure,
            overall_score: overallScore,
            recommendations: this.generateRecommendations({
                completeness,
                accuracy,
                freshness,
                consistency,
                structure
            })
        };
    }
    
    /**
     * å®Œæ•´æ€§è©•ä¼°
     * 
     * æª¢æŸ¥çŸ¥è­˜æ˜¯å¦åŒ…å«å¿…è¦çš„è³‡è¨Š
     */
    private async assessCompleteness(
        content: string,
        metadata: any
    ): Promise<CompletenessScore> {
        const checks = {
            hasTitle: !!metadata.title,
            hasSummary: !!metadata.summary,
            hasTags: metadata.tags && metadata.tags.length > 0,
            hasCategory: !!metadata.category_suggestion,
            hasGovernance: !!metadata.governance,
            hasStructure: content.length > 500, // å…§å®¹é•·åº¦
            hasKeywords: this.extractKeywords(content).length > 5,
            hasEntities: this.extractEntities(content).length > 0
        };
        
        const score = Object.values(checks).filter(Boolean).length / Object.keys(checks).length;
        
        return {
            score,
            checks,
            missing: Object.entries(checks)
                .filter(([_, value]) => !value)
                .map(([key]) => key)
        };
    }
    
    /**
     * æº–ç¢ºæ€§è©•ä¼°
     * 
     * ä½¿ç”¨ AI æª¢æŸ¥å…§å®¹çš„é‚è¼¯ä¸€è‡´æ€§ã€äº‹å¯¦æ­£ç¢ºæ€§
     */
    private async assessAccuracy(
        content: string,
        metadata: any
    ): Promise<AccuracyScore> {
        const prompt = `
è«‹è©•ä¼°ä»¥ä¸‹çŸ¥è­˜æ–‡ä»¶çš„æº–ç¢ºæ€§ï¼š

æ–‡ä»¶æ¨™é¡Œï¼š${metadata.title || 'æœªæä¾›'}
æ–‡ä»¶æ‘˜è¦ï¼š${metadata.summary || 'æœªæä¾›'}
æ–‡ä»¶å…§å®¹ï¼ˆå‰ 2000 å­—ï¼‰ï¼š${content.slice(0, 2000)}

è«‹å¾ä»¥ä¸‹ç¶­åº¦è©•ä¼°ï¼š
1. é‚è¼¯ä¸€è‡´æ€§ï¼šå…§å®¹æ˜¯å¦é‚è¼¯ä¸€è‡´ï¼Œæ²’æœ‰çŸ›ç›¾ï¼Ÿ
2. äº‹å¯¦æ­£ç¢ºæ€§ï¼šé™³è¿°çš„äº‹å¯¦æ˜¯å¦åˆç†ï¼Ÿ
3. å°ˆæ¥­æ€§ï¼šå…§å®¹æ˜¯å¦å°ˆæ¥­ã€å¯ä¿¡ï¼Ÿ
4. å®Œæ•´æ€§ï¼šé—œéµè³‡è¨Šæ˜¯å¦å®Œæ•´ï¼Ÿ

è«‹å›å‚³ JSON æ ¼å¼ï¼š
{
  "logical_consistency": 0.0-1.0,
  "factual_correctness": 0.0-1.0,
  "professionalism": 0.0-1.0,
  "completeness": 0.0-1.0,
  "overall_score": 0.0-1.0,
  "issues": ["å•é¡Œ 1", "å•é¡Œ 2"],
  "recommendations": ["å»ºè­° 1", "å»ºè­° 2"]
}
`;
        
        const result = await generateContent('gemini-3-flash-preview', prompt);
        const assessment = JSON.parse(result);
        
        return {
            score: assessment.overall_score,
            logical_consistency: assessment.logical_consistency,
            factual_correctness: assessment.factual_correctness,
            professionalism: assessment.professionalism,
            issues: assessment.issues || [],
            recommendations: assessment.recommendations || []
        };
    }
    
    /**
     * æ™‚æ•ˆæ€§è©•ä¼°
     */
    private async assessFreshness(metadata: any): Promise<FreshnessScore> {
        const now = new Date();
        const created = new Date(metadata.created_at || now);
        const updated = new Date(metadata.updated_at || created);
        const validUntil = metadata.valid_until ? new Date(metadata.valid_until) : null;
        
        const ageInDays = (now.getTime() - updated.getTime()) / (1000 * 60 * 60 * 24);
        
        let score = 1.0;
        if (ageInDays > 365) score = 0.5;
        if (ageInDays > 730) score = 0.2;
        if (ageInDays > 1095) score = 0.0;
        
        // å¦‚æœå·²éæœŸï¼Œåˆ†æ•¸ç‚º 0
        if (validUntil && now > validUntil) {
            score = 0.0;
        }
        
        return {
            score,
            age_in_days: ageInDays,
            is_expired: validUntil ? now > validUntil : false,
            last_updated: updated.toISOString()
        };
    }
    
    /**
     * ä¸€è‡´æ€§è©•ä¼°
     * 
     * æª¢æŸ¥æª”åã€æ¨™ç±¤ã€é¡åˆ¥ã€å…§å®¹æ˜¯å¦ä¸€è‡´
     */
    private async assessConsistency(
        content: string,
        metadata: any
    ): Promise<ConsistencyScore> {
        const checks = {
            filename_category_match: this.checkFilenameCategoryMatch(
                metadata.suggested_filename,
                metadata.category_suggestion
            ),
            tags_content_match: this.checkTagsContentMatch(
                metadata.tags || [],
                content
            ),
            governance_consistency: this.checkGovernanceConsistency(metadata.governance),
            dikw_level_appropriate: this.checkDIKWLevelAppropriate(
                metadata.dikw_level,
                content
            )
        };
        
        const score = Object.values(checks).filter(Boolean).length / Object.keys(checks).length;
        
        return {
            score,
            checks,
            inconsistencies: Object.entries(checks)
                .filter(([_, value]) => !value)
                .map(([key]) => key)
        };
    }
    
    /**
     * çµæ§‹åŒ–ç¨‹åº¦è©•ä¼°
     */
    private async assessStructure(content: string): Promise<StructureScore> {
        const hasHeaders = /^#+\s/.test(content);
        const hasLists = /^[-*+]\s/.test(content) || /^\d+\.\s/.test(content);
        const hasTables = /\|.*\|/.test(content);
        const hasCodeBlocks = /```/.test(content);
        const paragraphCount = content.split('\n\n').length;
        
        const structureScore = (
            (hasHeaders ? 0.3 : 0) +
            (hasLists ? 0.2 : 0) +
            (hasTables ? 0.2 : 0) +
            (hasCodeBlocks ? 0.1 : 0) +
            (paragraphCount > 5 ? 0.2 : paragraphCount * 0.04)
        );
        
        return {
            score: Math.min(structureScore, 1.0),
            has_headers: hasHeaders,
            has_lists: hasLists,
            has_tables: hasTables,
            has_code_blocks: hasCodeBlocks,
            paragraph_count: paragraphCount
        };
    }
}
```

### 4. èªç¾©çŸ¥è­˜åœ–è­œï¼ˆSemantic Knowledge Graphï¼‰

#### 4.1 çŸ¥è­˜é—œè¯ç™¼ç¾

```typescript
// lib/knowledge/graph/semantic-graph-builder.ts

/**
 * èªç¾©çŸ¥è­˜åœ–è­œå»ºæ§‹å™¨
 * 
 * è‡ªå‹•ç™¼ç¾çŸ¥è­˜ä¹‹é–“çš„èªç¾©é—œè¯
 */
export class SemanticKnowledgeGraphBuilder {
    /**
     * å»ºæ§‹çŸ¥è­˜åœ–è­œ
     */
    async buildGraph(fileIds: string[]): Promise<KnowledgeGraph> {
        const nodes: GraphNode[] = [];
        const edges: GraphEdge[] = [];
        
        // 1. å»ºç«‹ç¯€é»ï¼ˆæª”æ¡ˆã€çŸ¥è­˜å¯¦ä¾‹ã€æ¡†æ¶ï¼‰
        for (const fileId of fileIds) {
            const file = await this.getFile(fileId);
            nodes.push({
                id: fileId,
                type: 'file',
                label: file.filename,
                data: {
                    dikw_level: file.dikw_level,
                    category: file.category_id,
                    department: file.department_id
                }
            });
            
            // é—œè¯çš„çŸ¥è­˜å¯¦ä¾‹
            const instances = await this.getInstancesForFile(fileId);
            for (const inst of instances) {
                nodes.push({
                    id: inst.id,
                    type: 'instance',
                    label: inst.title,
                    data: {
                        framework: inst.framework_id,
                        completeness: inst.completeness,
                        confidence: inst.confidence
                    }
                });
                
                // æª”æ¡ˆ -> å¯¦ä¾‹çš„é‚Š
                edges.push({
                    id: `e-${fileId}-${inst.id}`,
                    source: fileId,
                    target: inst.id,
                    type: 'derived_from',
                    weight: inst.confidence
                });
            }
        }
        
        // 2. ç™¼ç¾èªç¾©é—œè¯
        const semanticEdges = await this.discoverSemanticRelations(nodes);
        edges.push(...semanticEdges);
        
        // 3. ç™¼ç¾ä¾è³´é—œä¿‚
        const dependencyEdges = await this.discoverDependencies(nodes);
        edges.push(...dependencyEdges);
        
        // 4. ç™¼ç¾æ¡†æ¶é—œè¯
        const frameworkEdges = await this.discoverFrameworkRelations(nodes);
        edges.push(...frameworkEdges);
        
        return {
            nodes,
            edges,
            metadata: {
                node_count: nodes.length,
                edge_count: edges.length,
                density: edges.length / (nodes.length * (nodes.length - 1))
            }
        };
    }
    
    /**
     * ç™¼ç¾èªç¾©é—œè¯
     * 
     * ä½¿ç”¨ Embedding ç›¸ä¼¼åº¦ç™¼ç¾èªç¾©ç›¸é—œçš„çŸ¥è­˜
     */
    private async discoverSemanticRelations(
        nodes: GraphNode[]
    ): Promise<GraphEdge[]> {
        const fileNodes = nodes.filter(n => n.type === 'file');
        const edges: GraphEdge[] = [];
        
        // å…©å…©æ¯”è¼ƒ Embedding ç›¸ä¼¼åº¦
        for (let i = 0; i < fileNodes.length; i++) {
            for (let j = i + 1; j < fileNodes.length; j++) {
                const node1 = fileNodes[i];
                const node2 = fileNodes[j];
                
                const similarity = await this.calculateSimilarity(
                    node1.id,
                    node2.id
                );
                
                if (similarity > 0.75) { // ç›¸ä¼¼åº¦é–¾å€¼
                    edges.push({
                        id: `e-semantic-${node1.id}-${node2.id}`,
                        source: node1.id,
                        target: node2.id,
                        type: 'semantic_related',
                        weight: similarity
                    });
                }
            }
        }
        
        return edges;
    }
    
    /**
     * ç™¼ç¾ä¾è³´é—œä¿‚
     * 
     * åˆ†æå…§å®¹ä¸­çš„å¼•ç”¨ã€åƒè€ƒã€ä¾è³´é—œä¿‚
     */
    private async discoverDependencies(
        nodes: GraphNode[]
    ): Promise<GraphEdge[]> {
        const edges: GraphEdge[] = [];
        
        for (const node of nodes.filter(n => n.type === 'file')) {
            const file = await this.getFile(node.id);
            const content = file.markdown_content || '';
            
            // ä½¿ç”¨ AI åˆ†æä¾è³´é—œä¿‚
            const prompt = `
è«‹åˆ†æä»¥ä¸‹æ–‡ä»¶å…§å®¹ï¼Œæ‰¾å‡ºå®ƒå¼•ç”¨äº†å“ªäº›å…¶ä»–æ–‡ä»¶æˆ–çŸ¥è­˜ï¼š

æ–‡ä»¶æ¨™é¡Œï¼š${file.filename}
æ–‡ä»¶å…§å®¹ï¼ˆå‰ 2000 å­—ï¼‰ï¼š${content.slice(0, 2000)}

è«‹æ‰¾å‡ºï¼š
1. æ˜ç¢ºå¼•ç”¨çš„æ–‡ä»¶åç¨±
2. åƒè€ƒçš„çŸ¥è­˜æ¡†æ¶
3. ä¾è³´çš„å…¶ä»–çŸ¥è­˜

è«‹å›å‚³ JSON æ ¼å¼ï¼š
{
  "referenced_files": ["æ–‡ä»¶å 1", "æ–‡ä»¶å 2"],
  "referenced_frameworks": ["æ¡†æ¶ 1", "æ¡†æ¶ 2"],
  "dependencies": ["ä¾è³´ 1", "ä¾è³´ 2"]
}
`;
            
            const result = await generateContent('gemini-3-flash-preview', prompt);
            const analysis = JSON.parse(result);
            
            // å»ºç«‹ä¾è³´é‚Š
            for (const refFile of analysis.referenced_files || []) {
                const targetNode = nodes.find(n => 
                    n.type === 'file' && n.label.includes(refFile)
                );
                
                if (targetNode) {
                    edges.push({
                        id: `e-dep-${node.id}-${targetNode.id}`,
                        source: node.id,
                        target: targetNode.id,
                        type: 'depends_on',
                        weight: 0.8
                    });
                }
            }
        }
        
        return edges;
    }
}
```

### 5. çŸ¥è­˜æ¼”åŒ–è¿½è¹¤ç³»çµ±ï¼ˆKnowledge Evolution Trackingï¼‰

#### 5.1 ç‰ˆæœ¬æ¼”é€²è¿½è¹¤

```typescript
// lib/knowledge/evolution/evolution-tracker.ts

/**
 * çŸ¥è­˜æ¼”åŒ–è¿½è¹¤ç³»çµ±
 * 
 * è¿½è¹¤çŸ¥è­˜çš„ç‰ˆæœ¬æ¼”é€²ã€ä¾è³´é—œä¿‚ã€å½±éŸ¿ç¯„åœ
 */
export class KnowledgeEvolutionTracker {
    /**
     * è¿½è¹¤çŸ¥è­˜æ¼”åŒ–
     */
    async trackEvolution(fileId: string): Promise<EvolutionChain> {
        // 1. å–å¾—ç‰ˆæœ¬æ­·å²
        const versions = await this.getVersionHistory(fileId);
        
        // 2. åˆ†æè®Šæ›´å…§å®¹
        const changes = await this.analyzeChanges(versions);
        
        // 3. è¿½è¹¤ä¾è³´å½±éŸ¿
        const impact = await this.trackDependencyImpact(fileId);
        
        // 4. å»ºæ§‹æ¼”åŒ–éˆ
        return {
            file_id: fileId,
            versions,
            changes,
            impact,
            evolution_path: this.buildEvolutionPath(versions, changes)
        };
    }
    
    /**
     * åˆ†æè®Šæ›´å…§å®¹
     */
    private async analyzeChanges(
        versions: FileVersion[]
    ): Promise<ChangeAnalysis[]> {
        const changes: ChangeAnalysis[] = [];
        
        for (let i = 1; i < versions.length; i++) {
            const prev = versions[i - 1];
            const curr = versions[i];
            
            // ä½¿ç”¨ AI åˆ†æè®Šæ›´
            const prompt = `
è«‹æ¯”è¼ƒä»¥ä¸‹å…©å€‹ç‰ˆæœ¬çš„çŸ¥è­˜æ–‡ä»¶ï¼Œåˆ†æè®Šæ›´å…§å®¹ï¼š

ç‰ˆæœ¬ ${prev.version}ï¼š
${prev.content.slice(0, 2000)}

ç‰ˆæœ¬ ${curr.version}ï¼š
${curr.content.slice(0, 2000)}

è«‹åˆ†æï¼š
1. æ–°å¢çš„å…§å®¹
2. åˆªé™¤çš„å…§å®¹
3. ä¿®æ”¹çš„å…§å®¹
4. è®Šæ›´çš„å½±éŸ¿ç¯„åœ

è«‹å›å‚³ JSON æ ¼å¼ï¼š
{
  "added": ["æ–°å¢å…§å®¹ 1", "æ–°å¢å…§å®¹ 2"],
  "removed": ["åˆªé™¤å…§å®¹ 1", "åˆªé™¤å…§å®¹ 2"],
  "modified": ["ä¿®æ”¹å…§å®¹ 1", "ä¿®æ”¹å…§å®¹ 2"],
  "impact_scope": "å½±éŸ¿ç¯„åœæè¿°",
  "change_type": "major|minor|patch"
}
`;
            
            const result = await generateContent('gemini-3-flash-preview', prompt);
            const analysis = JSON.parse(result);
            
            changes.push({
                from_version: prev.version,
                to_version: curr.version,
                change_type: analysis.change_type,
                added: analysis.added || [],
                removed: analysis.removed || [],
                modified: analysis.modified || [],
                impact_scope: analysis.impact_scope
            });
        }
        
        return changes;
    }
    
    /**
     * è¿½è¹¤ä¾è³´å½±éŸ¿
     */
    private async trackDependencyImpact(
        fileId: string
    ): Promise<DependencyImpact> {
        // 1. æ‰¾å‡ºä¾è³´æ­¤æª”æ¡ˆçš„çŸ¥è­˜
        const dependents = await this.findDependents(fileId);
        
        // 2. è©•ä¼°å½±éŸ¿ç¯„åœ
        const impact = {
            affected_files: dependents.files.length,
            affected_instances: dependents.instances.length,
            affected_agents: dependents.agents.length,
            risk_level: this.calculateRiskLevel(dependents)
        };
        
        return impact;
    }
}
```

---

## ğŸ†• v3.0 é€²éšå­ç³»çµ±è¨­è¨ˆ

### 6. çŸ¥è­˜è¡°æ¸›æ¨¡å‹ï¼ˆKnowledge Decay Modelï¼‰

#### 6.1 è¨­è¨ˆç†å¿µ

**æ ¸å¿ƒå•é¡Œ**ï¼šä¸åŒé¡å‹çš„çŸ¥è­˜æœ‰ä¸åŒçš„ã€Œä¿é®®æœŸã€ï¼Œç°¡å–®çš„æ™‚é–“é–¾å€¼ç„¡æ³•ç²¾æº–åˆ¤æ–·çŸ¥è­˜æ˜¯å¦éæ™‚ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼šå»ºç«‹ä¾æ“šçŸ¥è­˜é¡å‹çš„ã€Œè¡°æ¸›æ›²ç·šæ¨¡å‹ã€ï¼Œè‡ªå‹•è¨ˆç®—çŸ¥è­˜çš„æœ‰æ•ˆæ€§åˆ†æ•¸ã€‚

#### 6.2 è¡°æ¸›æ›²ç·šé¡å‹å®šç¾©

```typescript
// lib/knowledge/decay/knowledge-decay-model.ts

/**
 * çŸ¥è­˜è¡°æ¸›æ¨¡å‹
 * 
 * ä¸åŒé¡å‹çŸ¥è­˜æœ‰ä¸åŒçš„ã€ŒåŠè¡°æœŸã€ï¼Œå°±åƒä¸åŒé£Ÿç‰©æœ‰ä¸åŒçš„ä¿é®®æœŸ
 */

export enum KnowledgeDecayType {
    STABLE = 'stable',         // ç©©å®šå‹ï¼ˆå¦‚æ³•è¦ã€æ”¿ç­–ï¼‰
    TECHNICAL = 'technical',   // æŠ€è¡“å‹ï¼ˆå¦‚ API æ–‡ä»¶ï¼‰
    MARKET = 'market',         // å¸‚å ´å‹ï¼ˆå¦‚ç«¶å“åˆ†æï¼‰
    EVENT = 'event',           // äº‹ä»¶å‹ï¼ˆå¦‚æœƒè­°è¨˜éŒ„ï¼‰
    PROCEDURAL = 'procedural', // æµç¨‹å‹ï¼ˆå¦‚ SOPï¼‰
    REFERENCE = 'reference'    // åƒè€ƒå‹ï¼ˆå¦‚ç™¾ç§‘çŸ¥è­˜ï¼‰
}

export interface DecayCurve {
    type: KnowledgeDecayType;
    halfLife: number;           // åŠè¡°æœŸï¼ˆå¤©ï¼‰
    minValidScore: number;      // æœ€ä½æœ‰æ•ˆåˆ†æ•¸é–¾å€¼
    decayFunction: 'exponential' | 'linear' | 'step';
}

/**
 * è¡°æ¸›æ›²ç·šé…ç½®è¡¨
 * 
 * åŠè¡°æœŸè¨­è¨ˆç†å¿µï¼š
 * - ç©©å®šå‹ï¼šæ³•è¦é€šå¸¸ 3-5 å¹´æ›´æ–°ï¼Œè¨­å®š 1095 å¤©ï¼ˆ3 å¹´ï¼‰
 * - æŠ€è¡“å‹ï¼šæŠ€è¡“è¿­ä»£å¿«ï¼Œè¨­å®š 365 å¤©ï¼ˆ1 å¹´ï¼‰
 * - å¸‚å ´å‹ï¼šå¸‚å ´è®ŠåŒ–è¿…é€Ÿï¼Œè¨­å®š 90 å¤©ï¼ˆ3 å€‹æœˆï¼‰
 * - äº‹ä»¶å‹ï¼šæœƒè­°è¨˜éŒ„æ™‚æ•ˆæ€§æœ€çŸ­ï¼Œè¨­å®š 30 å¤©ï¼ˆ1 å€‹æœˆï¼‰
 */
export const DECAY_CURVES: Map<KnowledgeDecayType, DecayCurve> = new Map([
    [KnowledgeDecayType.STABLE, {
        type: KnowledgeDecayType.STABLE,
        halfLife: 1095,  // 3 å¹´
        minValidScore: 0.3,
        decayFunction: 'exponential'
    }],
    [KnowledgeDecayType.TECHNICAL, {
        type: KnowledgeDecayType.TECHNICAL,
        halfLife: 365,   // 1 å¹´
        minValidScore: 0.4,
        decayFunction: 'exponential'
    }],
    [KnowledgeDecayType.MARKET, {
        type: KnowledgeDecayType.MARKET,
        halfLife: 90,    // 3 å€‹æœˆ
        minValidScore: 0.5,
        decayFunction: 'exponential'
    }],
    [KnowledgeDecayType.EVENT, {
        type: KnowledgeDecayType.EVENT,
        halfLife: 30,    // 1 å€‹æœˆ
        minValidScore: 0.3,
        decayFunction: 'exponential'
    }],
    [KnowledgeDecayType.PROCEDURAL, {
        type: KnowledgeDecayType.PROCEDURAL,
        halfLife: 548,   // 1.5 å¹´
        minValidScore: 0.5,
        decayFunction: 'step'  // SOP éæœŸå°±æ˜¯éæœŸï¼Œæ²’æœ‰æ¼¸é€²
    }],
    [KnowledgeDecayType.REFERENCE, {
        type: KnowledgeDecayType.REFERENCE,
        halfLife: 730,   // 2 å¹´
        minValidScore: 0.4,
        decayFunction: 'linear'
    }]
]);
```

#### 6.3 è¡°æ¸›åˆ†æ•¸è¨ˆç®—å¼•æ“

```typescript
// lib/knowledge/decay/decay-calculator.ts

/**
 * çŸ¥è­˜è¡°æ¸›åˆ†æ•¸è¨ˆç®—å™¨
 */
export class KnowledgeDecayCalculator {
    /**
     * è¨ˆç®—çŸ¥è­˜çš„æ™‚æ•ˆæ€§åˆ†æ•¸
     * 
     * @param decayType   çŸ¥è­˜è¡°æ¸›é¡å‹
     * @param updatedAt   æœ€å¾Œæ›´æ–°æ™‚é–“
     * @param validUntil  æ˜ç¢ºçš„å¤±æ•ˆæ™‚é–“ï¼ˆå¯é¸ï¼‰
     * @returns           æ™‚æ•ˆæ€§åˆ†æ•¸ï¼ˆ0-1ï¼‰
     */
    calculateDecayScore(
        decayType: KnowledgeDecayType,
        updatedAt: Date,
        validUntil?: Date | null
    ): DecayScore {
        // 1. å¦‚æœæœ‰æ˜ç¢ºå¤±æ•ˆæ™‚é–“ä¸”å·²éæœŸï¼Œç›´æ¥è¿”å› 0
        if (validUntil && new Date() > validUntil) {
            return {
                score: 0,
                status: 'expired',
                reason: 'å·²è¶…éæ˜ç¢ºè¨­å®šçš„å¤±æ•ˆæ—¥æœŸ',
                suggestedAction: 'archive_or_update'
            };
        }
        
        // 2. å–å¾—å°æ‡‰çš„è¡°æ¸›æ›²ç·š
        const curve = DECAY_CURVES.get(decayType) || DECAY_CURVES.get(KnowledgeDecayType.REFERENCE)!;
        
        // 3. è¨ˆç®—ç¶“éçš„å¤©æ•¸
        const now = new Date();
        const ageInDays = (now.getTime() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);
        
        // 4. æ ¹æ“šè¡°æ¸›å‡½æ•¸è¨ˆç®—åˆ†æ•¸
        let score: number;
        switch (curve.decayFunction) {
            case 'exponential':
                // æŒ‡æ•¸è¡°æ¸›ï¼šscore = (1/2)^(age/halfLife)
                score = Math.pow(0.5, ageInDays / curve.halfLife);
                break;
                
            case 'linear':
                // ç·šæ€§è¡°æ¸›ï¼šscore = 1 - age / (halfLife * 2)
                score = Math.max(0, 1 - ageInDays / (curve.halfLife * 2));
                break;
                
            case 'step':
                // éšæ¢¯è¡°æ¸›ï¼šè¶…éåŠè¡°æœŸç›´æ¥é™åˆ°æœ€ä½
                score = ageInDays <= curve.halfLife ? 1 : curve.minValidScore;
                break;
                
            default:
                score = Math.pow(0.5, ageInDays / curve.halfLife);
        }
        
        // 5. åˆ¤æ–·ç‹€æ…‹
        let status: DecayStatus;
        let suggestedAction: string;
        
        if (score >= 0.8) {
            status = 'fresh';
            suggestedAction = 'none';
        } else if (score >= 0.5) {
            status = 'aging';
            suggestedAction = 'review_recommended';
        } else if (score >= curve.minValidScore) {
            status = 'stale';
            suggestedAction = 'update_required';
        } else {
            status = 'expired';
            suggestedAction = 'archive_or_update';
        }
        
        return {
            score: Math.round(score * 100) / 100,
            status,
            reason: this.generateDecayReason(ageInDays, curve, status),
            suggestedAction,
            daysUntilExpiry: this.calculateDaysUntilExpiry(score, curve),
            decayType: decayType
        };
    }
    
    /**
     * è‡ªå‹•æ¨æ–·çŸ¥è­˜çš„è¡°æ¸›é¡å‹
     */
    async inferDecayType(
        content: string,
        metadata: any,
        categoryCode?: string
    ): Promise<KnowledgeDecayType> {
        // 1. å„ªå…ˆä½¿ç”¨é¡åˆ¥ä»£ç¢¼æ¨æ–·
        if (categoryCode) {
            const categoryMapping: Record<string, KnowledgeDecayType> = {
                'GOV': KnowledgeDecayType.STABLE,      // æ²»ç†é¡
                'POLICY': KnowledgeDecayType.STABLE,   // æ”¿ç­–é¡
                'TECH': KnowledgeDecayType.TECHNICAL,  // æŠ€è¡“é¡
                'API': KnowledgeDecayType.TECHNICAL,   // API æ–‡ä»¶
                'MARKET': KnowledgeDecayType.MARKET,   // å¸‚å ´é¡
                'COMPETITOR': KnowledgeDecayType.MARKET, // ç«¶å“åˆ†æ
                'MEETING': KnowledgeDecayType.EVENT,   // æœƒè­°è¨˜éŒ„
                'NEWS': KnowledgeDecayType.EVENT,      // æ–°èè³‡è¨Š
                'SOP': KnowledgeDecayType.PROCEDURAL,  // æ¨™æº–æµç¨‹
                'GUIDE': KnowledgeDecayType.REFERENCE  // æŒ‡å—åƒè€ƒ
            };
            
            const inferredType = categoryMapping[categoryCode.toUpperCase()];
            if (inferredType) return inferredType;
        }
        
        // 2. ä½¿ç”¨ AI æ¨æ–·
        const prompt = `
è«‹åˆ†æä»¥ä¸‹çŸ¥è­˜å…§å®¹ï¼Œåˆ¤æ–·å®ƒçš„ã€ŒçŸ¥è­˜é¡å‹ã€ç”¨æ–¼è¨ˆç®—æ™‚æ•ˆæ€§ï¼š

æ¨™é¡Œï¼š${metadata.title || 'æœªæä¾›'}
æ‘˜è¦ï¼š${metadata.summary || 'æœªæä¾›'}
å…§å®¹ç‰‡æ®µï¼š${content.slice(0, 1000)}

è«‹å¾ä»¥ä¸‹é¡å‹ä¸­é¸æ“‡æœ€é©åˆçš„ï¼š
- stableï¼šç©©å®šå‹çŸ¥è­˜ï¼ˆæ³•è¦ã€æ”¿ç­–ã€ç« ç¨‹ï¼Œè®ŠåŒ–é€±æœŸ 3 å¹´ä»¥ä¸Šï¼‰
- technicalï¼šæŠ€è¡“å‹çŸ¥è­˜ï¼ˆAPI æ–‡ä»¶ã€æŠ€è¡“è¦æ ¼ï¼Œè®ŠåŒ–é€±æœŸ 1 å¹´å·¦å³ï¼‰
- marketï¼šå¸‚å ´å‹çŸ¥è­˜ï¼ˆç«¶å“åˆ†æã€å¸‚å ´è¶¨å‹¢ï¼Œè®ŠåŒ–é€±æœŸ 3 å€‹æœˆï¼‰
- eventï¼šäº‹ä»¶å‹çŸ¥è­˜ï¼ˆæœƒè­°è¨˜éŒ„ã€æ–°èäº‹ä»¶ï¼Œæ™‚æ•ˆæ€§ 1 å€‹æœˆï¼‰
- proceduralï¼šæµç¨‹å‹çŸ¥è­˜ï¼ˆSOPã€æ“ä½œæ‰‹å†Šï¼Œéœ€è¦ç²¾ç¢ºéµå®ˆï¼‰
- referenceï¼šåƒè€ƒå‹çŸ¥è­˜ï¼ˆç™¾ç§‘ã€æ•™å­¸è³‡æ–™ï¼Œè®ŠåŒ–é€±æœŸ 2 å¹´ï¼‰

è«‹åªå›å‚³é¡å‹ä»£ç¢¼ï¼ˆå¦‚ stableï¼‰ï¼Œä¸è¦å…¶ä»–å…§å®¹ã€‚
`;
        
        const result = await generateContent('gemini-3-flash-preview', prompt);
        const typeCode = result.trim().toLowerCase();
        
        return (Object.values(KnowledgeDecayType).includes(typeCode as KnowledgeDecayType))
            ? typeCode as KnowledgeDecayType
            : KnowledgeDecayType.REFERENCE;
    }
}

type DecayStatus = 'fresh' | 'aging' | 'stale' | 'expired';

interface DecayScore {
    score: number;
    status: DecayStatus;
    reason: string;
    suggestedAction: string;
    daysUntilExpiry?: number;
    decayType?: KnowledgeDecayType;
}
```

#### 6.4 è³‡æ–™åº«çµæ§‹æ“´å……

```sql
-- æ–°å¢æ¬„ä½åˆ° files è¡¨
ALTER TABLE files ADD COLUMN IF NOT EXISTS 
    decay_type VARCHAR(20) DEFAULT 'reference';
    
ALTER TABLE files ADD COLUMN IF NOT EXISTS 
    decay_score DECIMAL(3,2) DEFAULT 1.0;
    
ALTER TABLE files ADD COLUMN IF NOT EXISTS 
    decay_status VARCHAR(20) DEFAULT 'fresh';
    
ALTER TABLE files ADD COLUMN IF NOT EXISTS 
    valid_until TIMESTAMPTZ DEFAULT NULL;

-- å»ºç«‹ç´¢å¼•ä»¥åŠ é€Ÿè¡°æ¸›ç‹€æ…‹æŸ¥è©¢
CREATE INDEX IF NOT EXISTS idx_files_decay_status 
    ON files(decay_status) WHERE gemini_state = 'SYNCED';
    
-- å®šæœŸæ›´æ–°è¡°æ¸›åˆ†æ•¸çš„å‡½æ•¸ï¼ˆå¯ç”¨ pg_cron æ’ç¨‹ï¼‰
CREATE OR REPLACE FUNCTION update_all_decay_scores()
RETURNS void AS $$
BEGIN
    -- é€éæ‡‰ç”¨å±¤ API å‘¼å«æ›´æ–°
    -- æ­¤è™•åƒ…ä½œç‚ºè§¸ç™¼é»
    RAISE NOTICE 'Decay scores update triggered';
END;
$$ LANGUAGE plpgsql;
```

---

### 7. åé¥‹å­¸ç¿’è¿´è·¯ï¼ˆFeedback Learning Loopï¼‰

#### 7.1 è¨­è¨ˆç†å¿µ

**æ ¸å¿ƒå•é¡Œ**ï¼šç³»çµ±åªè¨˜éŒ„çŸ¥è­˜è¢«ä½¿ç”¨æ¬¡æ•¸ï¼Œä½†ä¸çŸ¥é“ä½¿ç”¨æ•ˆæœå¥½ä¸å¥½ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼šå»ºç«‹å®Œæ•´çš„åé¥‹æ”¶é›†èˆ‡å­¸ç¿’æ©Ÿåˆ¶ï¼Œè®“çŸ¥è­˜å“è³ªè©•åˆ†èƒ½å¤ æŒçºŒå„ªåŒ–ã€‚

#### 7.2 åé¥‹é¡å‹å®šç¾©

```typescript
// lib/knowledge/feedback/feedback-types.ts

/**
 * åé¥‹ä¾†æºé¡å‹
 */
export enum FeedbackSource {
    USER_EXPLICIT = 'user_explicit',     // ä½¿ç”¨è€…æ˜ç¢ºåé¥‹ï¼ˆæŒ‰è®š/å€’è®šï¼‰
    USER_IMPLICIT = 'user_implicit',     // ä½¿ç”¨è€…éš±æ€§åé¥‹ï¼ˆç¹¼çºŒå°è©±/é‡æ–°æå•ï¼‰
    AGENT_SELF = 'agent_self',           // Agent è‡ªæˆ‘è©•ä¼°
    SYSTEM_AUDIT = 'system_audit'        // ç³»çµ±å¯©è¨ˆ
}

/**
 * åé¥‹äº‹ä»¶é¡å‹
 */
export interface KnowledgeFeedbackEvent {
    id: string;
    file_id: string;
    agent_id?: string;
    session_id?: string;
    
    // åé¥‹å…§å®¹
    source: FeedbackSource;
    sentiment: 'positive' | 'negative' | 'neutral';
    score: number;  // -1 åˆ° 1
    
    // è©³ç´°åé¥‹
    feedback_type: FeedbackType;
    details?: {
        user_correction?: string;      // ä½¿ç”¨è€…ä¿®æ­£å…§å®¹
        issue_category?: string;       // å•é¡Œé¡åˆ¥
        improvement_suggestion?: string; // æ”¹é€²å»ºè­°
    };
    
    // ä¸Šä¸‹æ–‡
    context: {
        query?: string;                 // åŸå§‹æŸ¥è©¢
        response_snippet?: string;      // å›æ‡‰ç‰‡æ®µ
        knowledge_used?: string;        // ä½¿ç”¨çš„çŸ¥è­˜ç‰‡æ®µ
    };
    
    created_at: string;
}

export enum FeedbackType {
    HELPFUL = 'helpful',               // æœ‰å¹«åŠ©
    NOT_HELPFUL = 'not_helpful',       // æ²’å¹«åŠ©
    OUTDATED = 'outdated',            // è³‡è¨Šéæ™‚
    INACCURATE = 'inaccurate',        // è³‡è¨Šä¸æ­£ç¢º
    INCOMPLETE = 'incomplete',         // è³‡è¨Šä¸å®Œæ•´
    IRRELEVANT = 'irrelevant',        // èˆ‡å•é¡Œç„¡é—œ
    PERFECT = 'perfect'               // å®Œç¾å›ç­”
}
```

#### 7.3 åé¥‹å­¸ç¿’å¼•æ“

```typescript
// lib/knowledge/feedback/feedback-learning-engine.ts

/**
 * åé¥‹å­¸ç¿’å¼•æ“
 * 
 * å¾ä½¿ç”¨åé¥‹ä¸­å­¸ç¿’ï¼ŒæŒçºŒå„ªåŒ–çŸ¥è­˜å“è³ªè©•åˆ†
 */
export class FeedbackLearningEngine {
    /**
     * è¨˜éŒ„åé¥‹äº‹ä»¶
     */
    async recordFeedback(event: KnowledgeFeedbackEvent): Promise<void> {
        // 1. å„²å­˜åé¥‹äº‹ä»¶
        await supabase.from('knowledge_feedback_events').insert(event);
        
        // 2. å³æ™‚æ›´æ–°çŸ¥è­˜çµ±è¨ˆ
        await this.updateKnowledgeStats(event.file_id);
        
        // 3. è§¸ç™¼å­¸ç¿’æµç¨‹ï¼ˆéåŒæ­¥ï¼‰
        this.triggerLearningProcess(event.file_id).catch(console.error);
    }
    
    /**
     * æ›´æ–°çŸ¥è­˜çµ±è¨ˆ
     */
    private async updateKnowledgeStats(fileId: string): Promise<void> {
        // è¨ˆç®—æœ€è¿‘ 90 å¤©çš„åé¥‹çµ±è¨ˆ
        const { data: stats } = await supabase.rpc('calculate_feedback_stats', {
            p_file_id: fileId,
            p_days: 90
        });
        
        // æ›´æ–° files è¡¨
        await supabase
            .from('files')
            .update({
                feedback_score: stats.weighted_score,
                feedback_count: stats.total_count,
                positive_ratio: stats.positive_ratio,
                last_feedback_at: new Date().toISOString()
            })
            .eq('id', fileId);
    }
    
    /**
     * è§¸ç™¼å­¸ç¿’æµç¨‹
     * 
     * ç•¶è² é¢åé¥‹ç´¯ç©åˆ°é–¾å€¼æ™‚ï¼Œè‡ªå‹•èª¿æ•´çŸ¥è­˜å“è³ªè©•åˆ†
     */
    private async triggerLearningProcess(fileId: string): Promise<void> {
        const file = await getFile(fileId);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦é™ç´š
        if (file.positive_ratio < 0.5 && file.feedback_count >= 5) {
            // è² é¢åé¥‹éå¤šï¼Œé™ä½å“è³ªåˆ†æ•¸
            const penaltyFactor = Math.max(0.5, file.positive_ratio);
            
            await supabase
                .from('files')
                .update({
                    'quality_score': file.quality_score * penaltyFactor,
                    'needs_review': true,
                    'review_reason': 'è² é¢åé¥‹ç´¯ç©ï¼Œå»ºè­°äººå·¥å¯©æŸ¥'
                })
                .eq('id', fileId);
            
            // ç™¼é€é€šçŸ¥
            await this.notifyKnowledgeOwner(fileId, 'quality_degradation');
        }
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦å‡ç´š
        if (file.positive_ratio > 0.9 && file.feedback_count >= 10) {
            // æ­£é¢åé¥‹å¾ˆå¤šï¼Œæå‡æ¬Šå¨æ€§åˆ†æ•¸
            const boostFactor = Math.min(1.2, 1 + (file.positive_ratio - 0.9));
            
            await supabase
                .from('files')
                .update({
                    'authority_score': Math.min(1.0, file.authority_score * boostFactor)
                })
                .eq('id', fileId);
        }
    }
    
    /**
     * å¾åé¥‹ä¸­å­¸ç¿’ä¸¦èª¿æ•´æ¬Šé‡
     * 
     * å®šæœŸåŸ·è¡Œï¼ˆæ¯æ—¥ï¼‰ï¼Œåˆ†ææ•´é«”åé¥‹æ¨¡å¼
     */
    async runDailyLearning(): Promise<LearningReport> {
        const report: LearningReport = {
            date: new Date().toISOString(),
            files_analyzed: 0,
            quality_adjustments: [],
            patterns_detected: []
        };
        
        // 1. åˆ†æéå» 7 å¤©çš„åé¥‹æ¨¡å¼
        const { data: feedbackPatterns } = await supabase.rpc(
            'analyze_feedback_patterns',
            { p_days: 7 }
        );
        
        // 2. è­˜åˆ¥å•é¡Œé¡åˆ¥æ¨¡å¼
        for (const pattern of feedbackPatterns) {
            if (pattern.issue_count >= 3) {
                report.patterns_detected.push({
                    file_id: pattern.file_id,
                    issue_category: pattern.issue_category,
                    occurrence_count: pattern.issue_count,
                    suggested_action: this.suggestAction(pattern)
                });
            }
        }
        
        // 3. æ›´æ–°å…¨åŸŸå­¸ç¿’æ¨¡å‹
        await this.updateGlobalModel(feedbackPatterns);
        
        return report;
    }
    
    /**
     * æ”¶é›†éš±æ€§åé¥‹
     * 
     * åˆ†æä½¿ç”¨è€…è¡Œç‚ºæ¨æ–·æ»¿æ„åº¦
     */
    async collectImplicitFeedback(
        sessionId: string,
        fileId: string,
        behavior: UserBehavior
    ): Promise<void> {
        let implicitScore = 0;
        
        // è¡Œç‚ºåˆ†æ
        if (behavior.followUpQuestions > 0) {
            // æœ‰è¿½å• = å¯èƒ½ä¸å¤ªæ»¿æ„
            implicitScore -= 0.2 * behavior.followUpQuestions;
        }
        
        if (behavior.sessionDuration > 60) {
            // é•·æ™‚é–“å°è©± = å¯èƒ½åœ¨å°‹æ‰¾ç­”æ¡ˆ
            implicitScore -= 0.1;
        }
        
        if (behavior.taskCompleted) {
            // å®Œæˆä»»å‹™ = æ»¿æ„
            implicitScore += 0.5;
        }
        
        if (behavior.copiedResponse) {
            // è¤‡è£½å›æ‡‰ = èªç‚ºæœ‰ç”¨
            implicitScore += 0.3;
        }
        
        // æ­£è¦åŒ–åˆ†æ•¸
        implicitScore = Math.max(-1, Math.min(1, implicitScore));
        
        // è¨˜éŒ„éš±æ€§åé¥‹
        await this.recordFeedback({
            id: generateId(),
            file_id: fileId,
            session_id: sessionId,
            source: FeedbackSource.USER_IMPLICIT,
            sentiment: implicitScore > 0 ? 'positive' : implicitScore < 0 ? 'negative' : 'neutral',
            score: implicitScore,
            feedback_type: implicitScore > 0 ? FeedbackType.HELPFUL : FeedbackType.NOT_HELPFUL,
            context: {},
            created_at: new Date().toISOString()
        });
    }
}

interface UserBehavior {
    followUpQuestions: number;
    sessionDuration: number;  // ç§’
    taskCompleted: boolean;
    copiedResponse: boolean;
}
```

#### 7.4 è³‡æ–™åº«çµæ§‹

```sql
-- åé¥‹äº‹ä»¶è¡¨
CREATE TABLE IF NOT EXISTS knowledge_feedback_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    agent_id UUID REFERENCES agents(id) ON DELETE SET NULL,
    session_id VARCHAR(255),
    
    source VARCHAR(30) NOT NULL,
    sentiment VARCHAR(10) NOT NULL,
    score DECIMAL(3,2) NOT NULL,
    feedback_type VARCHAR(30) NOT NULL,
    details JSONB DEFAULT '{}',
    context JSONB DEFAULT '{}',
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å»ºç«‹ç´¢å¼•
CREATE INDEX idx_feedback_file_id ON knowledge_feedback_events(file_id);
CREATE INDEX idx_feedback_created_at ON knowledge_feedback_events(created_at DESC);

-- æ–°å¢æ¬„ä½åˆ° files è¡¨
ALTER TABLE files ADD COLUMN IF NOT EXISTS feedback_score DECIMAL(3,2) DEFAULT 0.5;
ALTER TABLE files ADD COLUMN IF NOT EXISTS feedback_count INTEGER DEFAULT 0;
ALTER TABLE files ADD COLUMN IF NOT EXISTS positive_ratio DECIMAL(3,2) DEFAULT 0.5;
ALTER TABLE files ADD COLUMN IF NOT EXISTS last_feedback_at TIMESTAMPTZ;
ALTER TABLE files ADD COLUMN IF NOT EXISTS needs_review BOOLEAN DEFAULT FALSE;
ALTER TABLE files ADD COLUMN IF NOT EXISTS review_reason TEXT;

-- è¨ˆç®—åé¥‹çµ±è¨ˆçš„å‡½æ•¸
CREATE OR REPLACE FUNCTION calculate_feedback_stats(
    p_file_id UUID,
    p_days INTEGER
)
RETURNS TABLE(
    total_count INTEGER,
    positive_count INTEGER,
    negative_count INTEGER,
    positive_ratio DECIMAL,
    weighted_score DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_count,
        COUNT(*) FILTER (WHERE sentiment = 'positive')::INTEGER as positive_count,
        COUNT(*) FILTER (WHERE sentiment = 'negative')::INTEGER as negative_count,
        COALESCE(
            COUNT(*) FILTER (WHERE sentiment = 'positive')::DECIMAL / 
            NULLIF(COUNT(*)::DECIMAL, 0),
            0.5
        ) as positive_ratio,
        COALESCE(AVG(score), 0)::DECIMAL as weighted_score
    FROM knowledge_feedback_events
    WHERE file_id = p_file_id
    AND created_at >= NOW() - (p_days || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql;
```

---

### 8. çŸ¥è­˜ç¢ç‰‡èšåˆï¼ˆKnowledge Fragment Aggregationï¼‰

#### 8.1 è¨­è¨ˆç†å¿µ

**æ ¸å¿ƒå•é¡Œ**ï¼šä¼æ¥­çŸ¥è­˜å¾€å¾€åˆ†æ•£åœ¨å¤šä»½æ–‡ä»¶ä¸­ï¼ŒAgent åªèƒ½ç²å–ç‰‡æ®µè¦–è§’ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼šè‡ªå‹•ç™¼ç¾è¨è«–åŒä¸€æ¦‚å¿µçš„æ–‡ä»¶ï¼Œèšåˆæˆå®Œæ•´çš„ã€ŒçŸ¥è­˜å–®å…ƒã€ã€‚

#### 8.2 çŸ¥è­˜å–®å…ƒå®šç¾©

```typescript
// lib/knowledge/aggregation/knowledge-unit.ts

/**
 * çŸ¥è­˜å–®å…ƒï¼ˆKnowledge Unitï¼‰
 * 
 * å°‡å¤šä»½ç›¸é—œæ–‡ä»¶æ•´åˆç‚ºä¸€å€‹å®Œæ•´çš„çŸ¥è­˜è¦–è§’
 */
export interface KnowledgeUnit {
    id: string;
    
    // æ¦‚å¿µè­˜åˆ¥
    concept_id: string;           // æ ¸å¿ƒæ¦‚å¿µ ID
    concept_name: string;         // æ¦‚å¿µåç¨±ï¼ˆå¦‚ã€Œå“¡å·¥é›¢è·æµç¨‹ã€ï¼‰
    concept_description: string;  // æ¦‚å¿µæè¿°
    
    // ä¾†æºæ–‡ä»¶
    source_files: SourceFile[];   // çµ„æˆæ­¤çŸ¥è­˜å–®å…ƒçš„æ–‡ä»¶
    
    // èšåˆå…§å®¹
    synthesized_knowledge: string;  // AI åˆæˆçš„çµ±ä¸€çŸ¥è­˜
    
    // è¡çªè™•ç†
    conflicts: ConflictRecord[];    // ç™¼ç¾çš„è¡çª
    conflict_resolution: string;    // è¡çªè§£æ±ºèªªæ˜
    
    // å“è³ªæŒ‡æ¨™
    completeness_score: number;     // çŸ¥è­˜å®Œæ•´åº¦
    confidence_score: number;       // ç¶œåˆä¿¡å¿ƒåº¦
    coverage_map: CoverageMap;      // çŸ¥è­˜è¦†è“‹åœ°åœ–
    
    // å¾Œè¨­è³‡æ–™
    created_at: string;
    updated_at: string;
    auto_generated: boolean;
}

interface SourceFile {
    file_id: string;
    filename: string;
    contribution: string;         // æ­¤æ–‡ä»¶çš„è²¢ç»ï¼ˆå¦‚ã€Œæä¾› HR æµç¨‹ã€ï¼‰
    coverage_areas: string[];     // è¦†è“‹çš„çŸ¥è­˜é¢å‘
    weight: number;               // æ¬Šé‡ï¼ˆ0-1ï¼‰
}

interface ConflictRecord {
    type: 'contradiction' | 'inconsistency' | 'ambiguity';
    description: string;
    file_ids: string[];           // æ¶‰åŠçš„æ–‡ä»¶
    resolved: boolean;
    resolution_method?: string;
}

interface CoverageMap {
    total_aspects: number;        // ç¸½å…±éœ€è¦è¦†è“‹çš„é¢å‘
    covered_aspects: number;      // å·²è¦†è“‹çš„é¢å‘
    missing_aspects: string[];    // ç¼ºå¤±çš„é¢å‘
    aspect_details: AspectDetail[];
}

interface AspectDetail {
    aspect_name: string;          // é¢å‘åç¨±ï¼ˆå¦‚ã€Œæ¬Šé™é—œé–‰ã€ï¼‰
    covered_by: string[];         // ç”±å“ªäº›æ–‡ä»¶è¦†è“‹
    coverage_quality: number;     // è¦†è“‹å“è³ªï¼ˆ0-1ï¼‰
}
```

#### 8.3 çŸ¥è­˜èšåˆå¼•æ“

```typescript
// lib/knowledge/aggregation/aggregation-engine.ts

/**
 * çŸ¥è­˜èšåˆå¼•æ“
 * 
 * è‡ªå‹•ç™¼ç¾ä¸¦æ•´åˆåˆ†æ•£çš„çŸ¥è­˜ç¢ç‰‡
 */
export class KnowledgeAggregationEngine {
    /**
     * ç™¼ç¾å¯èšåˆçš„çŸ¥è­˜æ¦‚å¿µ
     */
    async discoverAggregationCandidates(): Promise<AggregationCandidate[]> {
        const candidates: AggregationCandidate[] = [];
        
        // 1. å–å¾—æ‰€æœ‰å·²åŒæ­¥çš„æ–‡ä»¶
        const { data: files } = await supabase
            .from('files')
            .select('id, filename, markdown_content, content_embedding, metadata_analysis')
            .eq('gemini_state', 'SYNCED')
            .not('content_embedding', 'is', null);
        
        // 2. ä½¿ç”¨ AI æå–æ¯ä»½æ–‡ä»¶çš„æ ¸å¿ƒæ¦‚å¿µ
        const filesConcepts = await Promise.all(
            files.map(f => this.extractConcepts(f))
        );
        
        // 3. èšé¡ç›¸ä¼¼æ¦‚å¿µ
        const conceptClusters = this.clusterConcepts(filesConcepts);
        
        // 4. è­˜åˆ¥å¯èšåˆçš„å€™é¸
        for (const cluster of conceptClusters) {
            if (cluster.files.length >= 2) {
                candidates.push({
                    concept_name: cluster.concept,
                    file_ids: cluster.files.map(f => f.id),
                    similarity_score: cluster.avgSimilarity,
                    estimated_completeness: this.estimateCompleteness(cluster)
                });
            }
        }
        
        return candidates.sort((a, b) => 
            b.estimated_completeness - a.estimated_completeness
        );
    }
    
    /**
     * åŸ·è¡ŒçŸ¥è­˜èšåˆ
     */
    async aggregateKnowledge(
        conceptName: string,
        fileIds: string[]
    ): Promise<KnowledgeUnit> {
        // 1. å–å¾—æ‰€æœ‰ä¾†æºæ–‡ä»¶
        const files = await this.getFiles(fileIds);
        
        // 2. åˆ†ææ¯ä»½æ–‡ä»¶çš„è²¢ç»
        const contributions = await this.analyzeContributions(conceptName, files);
        
        // 3. ç™¼ç¾è¡çª
        const conflicts = await this.detectConflicts(conceptName, files);
        
        // 4. åˆæˆçµ±ä¸€çŸ¥è­˜
        const synthesized = await this.synthesizeKnowledge(
            conceptName,
            files,
            contributions,
            conflicts
        );
        
        // 5. è¨ˆç®—è¦†è“‹åœ°åœ–
        const coverageMap = await this.calculateCoverageMap(conceptName, files);
        
        // 6. å»ºç«‹çŸ¥è­˜å–®å…ƒ
        const knowledgeUnit: KnowledgeUnit = {
            id: generateId(),
            concept_id: generateConceptId(conceptName),
            concept_name: conceptName,
            concept_description: synthesized.description,
            source_files: contributions,
            synthesized_knowledge: synthesized.content,
            conflicts: conflicts,
            conflict_resolution: synthesized.conflictResolution,
            completeness_score: coverageMap.covered_aspects / coverageMap.total_aspects,
            confidence_score: this.calculateConfidence(files, conflicts),
            coverage_map: coverageMap,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            auto_generated: true
        };
        
        // 7. å„²å­˜çŸ¥è­˜å–®å…ƒ
        await supabase.from('knowledge_units').insert(knowledgeUnit);
        
        return knowledgeUnit;
    }
    
    /**
     * åˆæˆçµ±ä¸€çŸ¥è­˜
     */
    private async synthesizeKnowledge(
        conceptName: string,
        files: FileData[],
        contributions: SourceFile[],
        conflicts: ConflictRecord[]
    ): Promise<SynthesisResult> {
        const filesContent = files.map(f => `
### æ–‡ä»¶ï¼š${f.filename}
${f.markdown_content?.slice(0, 3000) || 'ç„¡å…§å®¹'}
---
`).join('\n');
        
        const conflictsDescription = conflicts.length > 0
            ? `\nç™¼ç¾çš„è¡çªï¼š\n${conflicts.map(c => `- ${c.description}`).join('\n')}`
            : '';
        
        const prompt = `
ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„çŸ¥è­˜æ•´åˆå°ˆå®¶ã€‚è«‹å°‡ä»¥ä¸‹å¤šä»½æ–‡ä»¶æ•´åˆç‚ºä¸€ä»½å®Œæ•´ã€ä¸€è‡´çš„çŸ¥è­˜æ–‡ä»¶ã€‚

**æ•´åˆä¸»é¡Œ**ï¼š${conceptName}

**ä¾†æºæ–‡ä»¶**ï¼š
${filesContent}

${conflictsDescription}

**æ•´åˆè¦æ±‚**ï¼š
1. ç¶œåˆæ‰€æœ‰æ–‡ä»¶çš„è³‡è¨Šï¼Œå½¢æˆå®Œæ•´çš„çŸ¥è­˜æè¿°
2. å¦‚æœæœ‰è¡çªï¼Œè«‹é¸æ“‡æœ€æ–°ã€æœ€æ¬Šå¨çš„ç‰ˆæœ¬ï¼Œä¸¦èªªæ˜ç†ç”±
3. è£œå……å„æ–‡ä»¶ä¹‹é–“çš„é‚è¼¯é€£çµ
4. æ¨™ç¤ºä»ç„¶ç¼ºå¤±çš„çŸ¥è­˜é¢å‘

**è¼¸å‡ºæ ¼å¼ï¼ˆJSONï¼‰**ï¼š
{
    "description": "æ¦‚å¿µçš„ç°¡çŸ­æè¿°ï¼ˆ100å­—å…§ï¼‰",
    "content": "å®Œæ•´çš„æ•´åˆçŸ¥è­˜å…§å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰",
    "conflictResolution": "è¡çªè§£æ±ºçš„èªªæ˜ï¼ˆå¦‚ç„¡è¡çªå‰‡ç‚ºç©ºï¼‰",
    "missingAspects": ["ç¼ºå¤±é¢å‘1", "ç¼ºå¤±é¢å‘2"]
}
`;
        
        const result = await generateContent('gemini-3-pro-preview', prompt);
        return JSON.parse(result);
    }
    
    /**
     * åµæ¸¬çŸ¥è­˜è¡çª
     */
    private async detectConflicts(
        conceptName: string,
        files: FileData[]
    ): Promise<ConflictRecord[]> {
        const prompt = `
è«‹åˆ†æä»¥ä¸‹æ–‡ä»¶ï¼Œæ‰¾å‡ºé—œæ–¼ã€Œ${conceptName}ã€çš„è³‡è¨Šè¡çªï¼š

${files.map(f => `
### ${f.filename}
${f.markdown_content?.slice(0, 2000) || 'ç„¡å…§å®¹'}
`).join('\n---\n')}

è«‹æ‰¾å‡ºï¼š
1. ç›´æ¥çŸ›ç›¾ï¼ˆcontradictionï¼‰ï¼šå…©ä»½æ–‡ä»¶èªªæ³•ç›¸å
2. ä¸ä¸€è‡´ï¼ˆinconsistencyï¼‰ï¼šæ•¸å­—ã€æ—¥æœŸã€æ­¥é©Ÿé †åºä¸åŒ
3. æ¨¡ç³Šï¼ˆambiguityï¼‰ï¼šåŒä¸€æ¦‚å¿µåœ¨ä¸åŒæ–‡ä»¶æœ‰ä¸åŒå®šç¾©

è¼¸å‡º JSON æ ¼å¼ï¼š
{
    "conflicts": [
        {
            "type": "contradiction|inconsistency|ambiguity",
            "description": "è¡çªæè¿°",
            "files": ["æ–‡ä»¶å1", "æ–‡ä»¶å2"]
        }
    ]
}

å¦‚æœæ²’æœ‰è¡çªï¼Œå›å‚³ {"conflicts": []}
`;
        
        const result = await generateContent('gemini-3-flash-preview', prompt);
        const parsed = JSON.parse(result);
        
        return parsed.conflicts.map((c: any) => ({
            type: c.type,
            description: c.description,
            file_ids: files
                .filter(f => c.files.includes(f.filename))
                .map(f => f.id),
            resolved: false
        }));
    }
}
```

#### 8.4 è³‡æ–™åº«çµæ§‹

```sql
-- çŸ¥è­˜å–®å…ƒè¡¨
CREATE TABLE IF NOT EXISTS knowledge_units (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    concept_id VARCHAR(255) NOT NULL UNIQUE,
    concept_name VARCHAR(500) NOT NULL,
    concept_description TEXT,
    
    source_files JSONB NOT NULL DEFAULT '[]',
    synthesized_knowledge TEXT,
    
    conflicts JSONB DEFAULT '[]',
    conflict_resolution TEXT,
    
    completeness_score DECIMAL(3,2) DEFAULT 0,
    confidence_score DECIMAL(3,2) DEFAULT 0,
    coverage_map JSONB DEFAULT '{}',
    
    auto_generated BOOLEAN DEFAULT TRUE,
    needs_human_review BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- çŸ¥è­˜å–®å…ƒèˆ‡æ–‡ä»¶çš„é—œè¯è¡¨
CREATE TABLE IF NOT EXISTS knowledge_unit_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    unit_id UUID REFERENCES knowledge_units(id) ON DELETE CASCADE,
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    contribution TEXT,
    coverage_areas JSONB DEFAULT '[]',
    weight DECIMAL(3,2) DEFAULT 1.0,
    
    UNIQUE(unit_id, file_id)
);

-- å»ºç«‹ç´¢å¼•
CREATE INDEX idx_knowledge_units_concept ON knowledge_units(concept_name);
CREATE INDEX idx_knowledge_unit_files_unit ON knowledge_unit_files(unit_id);
CREATE INDEX idx_knowledge_unit_files_file ON knowledge_unit_files(file_id);
```

---

### 9. é«˜æ•ˆèƒ½èªç¾©æœå°‹ï¼ˆHigh-Performance Semantic Searchï¼‰

#### 9.1 è¨­è¨ˆç†å¿µ

**æ ¸å¿ƒå•é¡Œ**ï¼šå…©å…©æ¯”è¼ƒ Embedding çš„ O(nÂ²) æ¼”ç®—æ³•åœ¨è¬ç´šæ–‡ä»¶æ™‚æ¥µæ…¢ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼šä½¿ç”¨ Approximate Nearest Neighbor (ANN) æ¼”ç®—æ³•å¯¦ç¾è¿‘ä¼¼å³æ™‚æœå°‹ã€‚

#### 9.2 ANN ç´¢å¼•å¯¦ä½œ

```typescript
// lib/knowledge/search/ann-semantic-search.ts

/**
 * é«˜æ•ˆèƒ½èªç¾©æœå°‹å¼•æ“
 * 
 * ä½¿ç”¨ pgvector çš„ IVFFlat æˆ– HNSW ç´¢å¼•å¯¦ç¾å¿«é€Ÿå‘é‡æœå°‹
 */
export class ANNSemanticSearchEngine {
    /**
     * èªç¾©æœå°‹ï¼ˆä½¿ç”¨ ANN ç´¢å¼•ï¼‰
     * 
     * @param query      æœå°‹æŸ¥è©¢
     * @param topK       è¿”å›å‰ K å€‹çµæœ
     * @param filters    é¡å¤–éæ¿¾æ¢ä»¶
     */
    async semanticSearch(
        query: string,
        topK: number = 10,
        filters?: SearchFilters
    ): Promise<SearchResult[]> {
        // 1. ç”ŸæˆæŸ¥è©¢å‘é‡
        const queryEmbedding = await generateEmbedding(query);
        
        // 2. ä½¿ç”¨ pgvector çš„å‘é‡æœå°‹ï¼ˆå·²å»ºç«‹ HNSW ç´¢å¼•ï¼‰
        const { data: results } = await supabase.rpc('semantic_search_ann', {
            query_embedding: queryEmbedding,
            similarity_threshold: 0.7,
            match_count: topK,
            filter_department: filters?.departmentId || null,
            filter_category: filters?.categoryId || null,
            filter_dikw_level: filters?.dikwLevel || null
        });
        
        return results.map((r: any) => ({
            file_id: r.id,
            filename: r.filename,
            similarity: r.similarity,
            snippet: r.snippet,
            dikw_level: r.dikw_level,
            decay_score: r.decay_score
        }));
    }
    
    /**
     * æ‰¹é‡ç›¸ä¼¼åº¦æœå°‹
     * 
     * ç”¨æ–¼å»ºæ§‹çŸ¥è­˜åœ–è­œæ™‚çš„æ‰¹é‡é—œè¯ç™¼ç¾
     */
    async batchSimilaritySearch(
        fileIds: string[],
        similarityThreshold: number = 0.75
    ): Promise<SimilarityEdge[]> {
        const edges: SimilarityEdge[] = [];
        
        // ä½¿ç”¨ SQL æ‰¹é‡è¨ˆç®—ï¼ˆæ¯”æ‡‰ç”¨å±¤å…©å…©æ¯”è¼ƒå¿« 100 å€ï¼‰
        const { data: similarities } = await supabase.rpc('batch_similarity_matrix', {
            file_ids: fileIds,
            threshold: similarityThreshold
        });
        
        for (const sim of similarities) {
            edges.push({
                source_id: sim.file_id_1,
                target_id: sim.file_id_2,
                similarity: sim.similarity
            });
        }
        
        return edges;
    }
    
    /**
     * å¢é‡æ›´æ–°ç´¢å¼•
     * 
     * æ–°æ–‡ä»¶ä¸Šå‚³æ™‚ï¼Œåªéœ€æ›´æ–°å¢é‡éƒ¨åˆ†
     */
    async updateIndex(fileId: string, embedding: number[]): Promise<void> {
        // HNSW ç´¢å¼•æ”¯æ´å¢é‡æ›´æ–°
        await supabase
            .from('files')
            .update({ content_embedding: embedding })
            .eq('id', fileId);
        
        // è§¸ç™¼ç›¸é—œæ€§è¨ˆç®—ï¼ˆéåŒæ­¥ï¼‰
        this.recalculateRelations(fileId).catch(console.error);
    }
    
    /**
     * é‡æ–°è¨ˆç®—èˆ‡æ–°æ–‡ä»¶çš„é—œè¯
     */
    private async recalculateRelations(newFileId: string): Promise<void> {
        // åªè¨ˆç®—èˆ‡æ–°æ–‡ä»¶ç›¸é—œçš„é‚Šï¼Œä¸é‡ç®—æ•´å€‹åœ–
        const { data: newFile } = await supabase
            .from('files')
            .select('content_embedding')
            .eq('id', newFileId)
            .single();
        
        if (!newFile?.content_embedding) return;
        
        // æ‰¾å‡ºèˆ‡æ–°æ–‡ä»¶ç›¸ä¼¼çš„ç¾æœ‰æ–‡ä»¶
        const { data: similarFiles } = await supabase.rpc('find_similar_files', {
            query_embedding: newFile.content_embedding,
            threshold: 0.75,
            limit_count: 20,
            exclude_id: newFileId
        });
        
        // å»ºç«‹é—œè¯é‚Š
        const edges = similarFiles.map((f: any) => ({
            source_file_id: newFileId,
            target_file_id: f.id,
            relation_type: 'semantic_similar',
            weight: f.similarity,
            created_at: new Date().toISOString()
        }));
        
        if (edges.length > 0) {
            await supabase.from('knowledge_relations').upsert(edges, {
                onConflict: 'source_file_id,target_file_id,relation_type'
            });
        }
    }
}

interface SearchFilters {
    departmentId?: string;
    categoryId?: string;
    dikwLevel?: string;
    decayStatus?: string[];
}

interface SimilarityEdge {
    source_id: string;
    target_id: string;
    similarity: number;
}
```

#### 9.3 PostgreSQL + pgvector å„ªåŒ–é…ç½®

```sql
-- ç¢ºä¿ pgvector æ“´å±•å·²å•Ÿç”¨
CREATE EXTENSION IF NOT EXISTS vector;

-- ç‚º content_embedding å»ºç«‹ HNSW ç´¢å¼•ï¼ˆæ¨è–¦ç”¨æ–¼é«˜ç¶­å‘é‡ï¼‰
-- HNSW æ¯” IVFFlat æ›´å¿«ï¼Œä½†ä½”ç”¨æ›´å¤šç©ºé–“
CREATE INDEX IF NOT EXISTS idx_files_embedding_hnsw 
    ON files 
    USING hnsw (content_embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

-- èªç¾©æœå°‹å‡½æ•¸ï¼ˆä½¿ç”¨ ANN ç´¢å¼•ï¼‰
CREATE OR REPLACE FUNCTION semantic_search_ann(
    query_embedding vector(1536),
    similarity_threshold FLOAT DEFAULT 0.7,
    match_count INTEGER DEFAULT 10,
    filter_department UUID DEFAULT NULL,
    filter_category UUID DEFAULT NULL,
    filter_dikw_level TEXT DEFAULT NULL
)
RETURNS TABLE(
    id UUID,
    filename TEXT,
    similarity FLOAT,
    snippet TEXT,
    dikw_level TEXT,
    decay_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        f.id,
        f.filename,
        1 - (f.content_embedding <=> query_embedding) as similarity,
        LEFT(f.markdown_content, 200) as snippet,
        f.dikw_level,
        f.decay_score
    FROM files f
    WHERE f.gemini_state = 'SYNCED'
    AND f.content_embedding IS NOT NULL
    AND (filter_department IS NULL OR f.department_id = filter_department)
    AND (filter_category IS NULL OR f.category_id = filter_category)
    AND (filter_dikw_level IS NULL OR f.dikw_level = filter_dikw_level)
    AND 1 - (f.content_embedding <=> query_embedding) >= similarity_threshold
    ORDER BY f.content_embedding <=> query_embedding
    LIMIT match_count;
END;
$$ LANGUAGE plpgsql;

-- æ‰¹é‡ç›¸ä¼¼åº¦çŸ©é™£è¨ˆç®—å‡½æ•¸
CREATE OR REPLACE FUNCTION batch_similarity_matrix(
    file_ids UUID[],
    threshold FLOAT DEFAULT 0.75
)
RETURNS TABLE(
    file_id_1 UUID,
    file_id_2 UUID,
    similarity FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        f1.id as file_id_1,
        f2.id as file_id_2,
        1 - (f1.content_embedding <=> f2.content_embedding) as similarity
    FROM files f1
    CROSS JOIN files f2
    WHERE f1.id = ANY(file_ids)
    AND f2.id = ANY(file_ids)
    AND f1.id < f2.id  -- é¿å…é‡è¤‡è¨ˆç®—
    AND 1 - (f1.content_embedding <=> f2.content_embedding) >= threshold;
END;
$$ LANGUAGE plpgsql;

-- æ•ˆèƒ½é…ç½®å»ºè­°
-- åœ¨ postgresql.conf ä¸­è¨­å®šï¼š
-- effective_cache_size = 4GBï¼ˆæˆ–ç³»çµ±è¨˜æ†¶é«”çš„ 50-75%ï¼‰
-- maintenance_work_mem = 1GBï¼ˆå»ºç«‹ç´¢å¼•æ™‚ï¼‰
-- hnsw.ef_search = 100ï¼ˆæœå°‹æ™‚çš„éæ­·æ·±åº¦ï¼Œè¶Šå¤§è¶Šæº–ä½†è¶Šæ…¢ï¼‰
```

#### 9.4 æ•ˆèƒ½å°æ¯”

| æ¼”ç®—æ³• | æ™‚é–“è¤‡é›œåº¦ | 10,000 æª”æ¡ˆ | 100,000 æª”æ¡ˆ | ç²¾ç¢ºåº¦ |
|-------|-----------|-------------|--------------|--------|
| æš´åŠ›æ³• (Brute Force) | O(nÂ²) | ~5 åˆ†é˜ | ~8 å°æ™‚ | 100% |
| IVFFlat | O(nÂ·âˆšn) | ~3 ç§’ | ~30 ç§’ | ~95% |
| **HNSW** | O(nÂ·log n) | **<1 ç§’** | **~5 ç§’** | **~98%** |

---

### 10. ä¸»å‹•æ¨é€æ©Ÿåˆ¶ï¼ˆProactive Knowledge Pushï¼‰

#### 10.1 è¨­è¨ˆç†å¿µ

**æ ¸å¿ƒå•é¡Œ**ï¼šçŸ¥è­˜æ›´æ–°æ™‚ï¼Œä½¿ç”¨è©²çŸ¥è­˜çš„ Agent ä¸æœƒè‡ªå‹•çŸ¥é“ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼šå»ºç«‹äº‹ä»¶é©…å‹•çš„ä¸»å‹•é€šçŸ¥ç³»çµ±ã€‚

#### 10.2 é€šçŸ¥äº‹ä»¶é¡å‹

```typescript
// lib/knowledge/push/notification-types.ts

/**
 * çŸ¥è­˜è®Šæ›´é€šçŸ¥é¡å‹
 */
export enum KnowledgeNotificationType {
    // ç·Šæ€¥é€šçŸ¥ï¼ˆéœ€ç«‹å³è™•ç†ï¼‰
    KNOWLEDGE_EXPIRED = 'knowledge_expired',           // çŸ¥è­˜å·²éæœŸ
    CRITICAL_UPDATE = 'critical_update',               // é—œéµçŸ¥è­˜æ›´æ–°
    CONFLICT_DETECTED = 'conflict_detected',           // ç™¼ç¾çŸ¥è­˜è¡çª
    
    // é‡è¦é€šçŸ¥ï¼ˆå»ºè­°ç•¶æ—¥è™•ç†ï¼‰
    KNOWLEDGE_UPDATED = 'knowledge_updated',           // çŸ¥è­˜å·²æ›´æ–°
    QUALITY_DEGRADATION = 'quality_degradation',       // å“è³ªä¸‹é™
    APPROACHING_EXPIRY = 'approaching_expiry',         // å³å°‡éæœŸ
    
    // è³‡è¨Šé€šçŸ¥ï¼ˆå¯ç¨å¾Œè™•ç†ï¼‰
    NEW_RELATED_KNOWLEDGE = 'new_related_knowledge',   // æ–°å¢ç›¸é—œçŸ¥è­˜
    AGGREGATION_AVAILABLE = 'aggregation_available',   // å¯é€²è¡ŒçŸ¥è­˜èšåˆ
    FEEDBACK_SUMMARY = 'feedback_summary'              // åé¥‹æ‘˜è¦
}

/**
 * é€šçŸ¥äº‹ä»¶
 */
export interface KnowledgeNotification {
    id: string;
    type: KnowledgeNotificationType;
    priority: 'urgent' | 'high' | 'normal' | 'low';
    
    // å—å½±éŸ¿çš„å°è±¡
    affected_files: string[];
    affected_agents: string[];
    affected_users: string[];
    
    // é€šçŸ¥å…§å®¹
    title: string;
    message: string;
    details: Record<string, any>;
    
    // å»ºè­°å‹•ä½œ
    suggested_actions: SuggestedAction[];
    
    // ç‹€æ…‹
    status: 'pending' | 'sent' | 'read' | 'resolved';
    created_at: string;
    resolved_at?: string;
}

interface SuggestedAction {
    action_type: string;
    label: string;
    url?: string;
    params?: Record<string, any>;
}
```

#### 10.3 ä¸»å‹•æ¨é€å¼•æ“

```typescript
// lib/knowledge/push/proactive-push-engine.ts

/**
 * ä¸»å‹•æ¨é€å¼•æ“
 * 
 * ç›£æ§çŸ¥è­˜è®ŠåŒ–ï¼Œè‡ªå‹•é€šçŸ¥ç›¸é—œ Agent å’Œä½¿ç”¨è€…
 */
export class ProactivePushEngine {
    /**
     * è™•ç†çŸ¥è­˜æ›´æ–°äº‹ä»¶
     */
    async handleKnowledgeUpdate(
        fileId: string,
        changeType: 'created' | 'updated' | 'deleted'
    ): Promise<void> {
        // 1. æ‰¾å‡ºä½¿ç”¨æ­¤çŸ¥è­˜çš„ Agent
        const affectedAgents = await this.findAffectedAgents(fileId);
        
        // 2. æ‰¾å‡ºç›¸é—œçš„çŸ¥è­˜å–®å…ƒ
        const affectedUnits = await this.findAffectedUnits(fileId);
        
        // 3. è©•ä¼°å½±éŸ¿ç¨‹åº¦
        const impact = await this.assessImpact(fileId, changeType);
        
        // 4. å»ºç«‹é€šçŸ¥
        const notification = this.createNotification(
            changeType === 'deleted' 
                ? KnowledgeNotificationType.CRITICAL_UPDATE
                : KnowledgeNotificationType.KNOWLEDGE_UPDATED,
            fileId,
            affectedAgents,
            affectedUnits,
            impact
        );
        
        // 5. ç™¼é€é€šçŸ¥
        await this.sendNotification(notification);
        
        // 6. è§¸ç™¼å¾ŒçºŒå‹•ä½œ
        if (impact.severity === 'critical') {
            await this.triggerEmergencyActions(notification);
        }
    }
    
    /**
     * æª¢æŸ¥å³å°‡éæœŸçš„çŸ¥è­˜ï¼ˆå®šæœŸåŸ·è¡Œï¼‰
     */
    async checkApproachingExpiry(): Promise<void> {
        // æ‰¾å‡º 7 å¤©å…§å³å°‡éæœŸçš„çŸ¥è­˜
        const { data: expiringFiles } = await supabase
            .from('files')
            .select('id, filename, decay_score, decay_status, valid_until')
            .or(`decay_status.eq.stale,valid_until.lte.${addDays(new Date(), 7).toISOString()}`)
            .eq('gemini_state', 'SYNCED');
        
        for (const file of expiringFiles) {
            const affectedAgents = await this.findAffectedAgents(file.id);
            
            if (affectedAgents.length > 0) {
                const notification = this.createNotification(
                    KnowledgeNotificationType.APPROACHING_EXPIRY,
                    file.id,
                    affectedAgents,
                    [],
                    {
                        severity: 'warning',
                        days_until_expiry: this.calculateDaysUntilExpiry(file)
                    }
                );
                
                await this.sendNotification(notification);
            }
        }
    }
    
    /**
     * åµæ¸¬çŸ¥è­˜è¡çª
     */
    async detectAndNotifyConflicts(): Promise<void> {
        // æ‰¾å‡ºæœ‰è¡çªçš„çŸ¥è­˜å–®å…ƒ
        const { data: conflictedUnits } = await supabase
            .from('knowledge_units')
            .select('*')
            .containedBy('conflicts', [{ resolved: false }])
            .eq('needs_human_review', true);
        
        for (const unit of conflictedUnits) {
            const notification = this.createNotification(
                KnowledgeNotificationType.CONFLICT_DETECTED,
                null,
                [],
                [unit.id],
                {
                    severity: 'high',
                    conflict_count: unit.conflicts.length,
                    concept_name: unit.concept_name
                }
            );
            
            // é€šçŸ¥çŸ¥è­˜æ“æœ‰è€…
            const owners = await this.findKnowledgeOwners(unit.source_files);
            notification.affected_users = owners;
            
            await this.sendNotification(notification);
        }
    }
    
    /**
     * æ‰¾å‡ºä½¿ç”¨ç‰¹å®šçŸ¥è­˜çš„ Agent
     */
    private async findAffectedAgents(fileId: string): Promise<string[]> {
        const { data: agentFiles } = await supabase
            .from('agent_knowledge_sources')
            .select('agent_id')
            .eq('file_id', fileId);
        
        return agentFiles?.map(af => af.agent_id) || [];
    }
    
    /**
     * ç™¼é€é€šçŸ¥
     */
    private async sendNotification(
        notification: KnowledgeNotification
    ): Promise<void> {
        // 1. å„²å­˜é€šçŸ¥
        await supabase.from('knowledge_notifications').insert(notification);
        
        // 2. æ ¹æ“šå„ªå…ˆç´šé¸æ“‡é€šçŸ¥æ–¹å¼
        if (notification.priority === 'urgent') {
            // ç·Šæ€¥ï¼šå³æ™‚æ¨é€ + Email
            await this.sendPushNotification(notification);
            await this.sendEmailNotification(notification);
        } else if (notification.priority === 'high') {
            // é‡è¦ï¼šå³æ™‚æ¨é€
            await this.sendPushNotification(notification);
        }
        
        // 3. æ›´æ–° Agent ç‹€æ…‹ï¼ˆå¦‚æœé©ç”¨ï¼‰
        for (const agentId of notification.affected_agents) {
            await supabase
                .from('agents')
                .update({
                    knowledge_status: 'needs_review',
                    last_knowledge_alert: new Date().toISOString()
                })
                .eq('id', agentId);
        }
    }
    
    /**
     * è§¸ç™¼ç·Šæ€¥å‹•ä½œ
     */
    private async triggerEmergencyActions(
        notification: KnowledgeNotification
    ): Promise<void> {
        // å°æ–¼é—œéµæ›´æ–°ï¼Œè‡ªå‹•å°‡å—å½±éŸ¿çš„ Agent æ¨™è¨˜ç‚ºéœ€è¦é‡æ–°è¨“ç·´
        for (const agentId of notification.affected_agents) {
            await supabase
                .from('agents')
                .update({
                    status: 'needs_retraining',
                    status_reason: `é—œéµçŸ¥è­˜æ›´æ–°ï¼š${notification.title}`
                })
                .eq('id', agentId);
        }
    }
    
    /**
     * å»ºç«‹é€šçŸ¥ç‰©ä»¶
     */
    private createNotification(
        type: KnowledgeNotificationType,
        fileId: string | null,
        affectedAgents: string[],
        affectedUnits: string[],
        impactDetails: Record<string, any>
    ): KnowledgeNotification {
        const priorityMap: Record<KnowledgeNotificationType, 'urgent' | 'high' | 'normal' | 'low'> = {
            [KnowledgeNotificationType.KNOWLEDGE_EXPIRED]: 'urgent',
            [KnowledgeNotificationType.CRITICAL_UPDATE]: 'urgent',
            [KnowledgeNotificationType.CONFLICT_DETECTED]: 'high',
            [KnowledgeNotificationType.KNOWLEDGE_UPDATED]: 'normal',
            [KnowledgeNotificationType.QUALITY_DEGRADATION]: 'high',
            [KnowledgeNotificationType.APPROACHING_EXPIRY]: 'normal',
            [KnowledgeNotificationType.NEW_RELATED_KNOWLEDGE]: 'low',
            [KnowledgeNotificationType.AGGREGATION_AVAILABLE]: 'low',
            [KnowledgeNotificationType.FEEDBACK_SUMMARY]: 'low'
        };
        
        return {
            id: generateId(),
            type,
            priority: priorityMap[type],
            affected_files: fileId ? [fileId] : [],
            affected_agents: affectedAgents,
            affected_users: [],
            title: this.getNotificationTitle(type),
            message: this.getNotificationMessage(type, impactDetails),
            details: impactDetails,
            suggested_actions: this.getSuggestedActions(type),
            status: 'pending',
            created_at: new Date().toISOString()
        };
    }
}
```

#### 10.4 è³‡æ–™åº«çµæ§‹

```sql
-- é€šçŸ¥è¡¨
CREATE TABLE IF NOT EXISTS knowledge_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(50) NOT NULL,
    priority VARCHAR(10) NOT NULL,
    
    affected_files UUID[] DEFAULT '{}',
    affected_agents UUID[] DEFAULT '{}',
    affected_users UUID[] DEFAULT '{}',
    
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    details JSONB DEFAULT '{}',
    suggested_actions JSONB DEFAULT '[]',
    
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    read_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    resolved_by UUID REFERENCES user_profiles(id)
);

-- Agent çŸ¥è­˜ä¾†æºé—œè¯è¡¨ï¼ˆç”¨æ–¼è¿½è¹¤å½±éŸ¿ç¯„åœï¼‰
CREATE TABLE IF NOT EXISTS agent_knowledge_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID REFERENCES agents(id) ON DELETE CASCADE,
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    added_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(agent_id, file_id)
);

-- æ–°å¢æ¬„ä½åˆ° agents è¡¨
ALTER TABLE agents ADD COLUMN IF NOT EXISTS knowledge_status VARCHAR(30) DEFAULT 'up_to_date';
ALTER TABLE agents ADD COLUMN IF NOT EXISTS last_knowledge_alert TIMESTAMPTZ;
ALTER TABLE agents ADD COLUMN IF NOT EXISTS status_reason TEXT;

-- å»ºç«‹ç´¢å¼•
CREATE INDEX idx_notifications_status ON knowledge_notifications(status);
CREATE INDEX idx_notifications_priority ON knowledge_notifications(priority);
CREATE INDEX idx_notifications_created ON knowledge_notifications(created_at DESC);
CREATE INDEX idx_agent_knowledge_sources_agent ON agent_knowledge_sources(agent_id);
CREATE INDEX idx_agent_knowledge_sources_file ON agent_knowledge_sources(file_id);

-- çŸ¥è­˜æ›´æ–°è§¸ç™¼å™¨
CREATE OR REPLACE FUNCTION notify_knowledge_update()
RETURNS TRIGGER AS $$
BEGIN
    -- ç™¼é€é€šçŸ¥åˆ°æ‡‰ç”¨å±¤ï¼ˆé€é Supabase Realtimeï¼‰
    PERFORM pg_notify(
        'knowledge_update',
        json_build_object(
            'file_id', NEW.id,
            'action', TG_OP,
            'updated_at', NEW.updated_at
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_knowledge_update
    AFTER INSERT OR UPDATE ON files
    FOR EACH ROW
    WHEN (NEW.gemini_state = 'SYNCED')
    EXECUTE FUNCTION notify_knowledge_update();
```

---

## ğŸ¯ Agent æ•´åˆè¨­è¨ˆ

### Agent çŸ¥è­˜è·¯ç”±æ•´åˆ

ç•¶ä½¿ç”¨è€…å»ºç«‹ Agent æ™‚ï¼Œç³»çµ±æœƒè‡ªå‹•ï¼š

1. **åˆ†æ Agent ä»»å‹™æè¿°**
2. **åŒ¹é…ç›¸é—œçŸ¥è­˜æ¡†æ¶**
3. **é¸æ“‡æœ€ç›¸é—œçš„çŸ¥è­˜ä¾†æº**
4. **ç”Ÿæˆ Agent System Prompt**

```typescript
// app/api/agents/architect/route.ts (æ“´å……ç‰ˆ)

export async function POST(request: NextRequest) {
    const { description, skills, department_id } = await request.json();
    
    // 1. ä½¿ç”¨çŸ¥è­˜è·¯ç”±ç³»çµ±é¸æ“‡çŸ¥è­˜ä¾†æº
    const router = new AgentKnowledgeRouter();
    const knowledgeRoutes = await router.routeKnowledgeForAgent(
        description,
        skills,
        department_id
    );
    
    // 2. å»ºæ§‹çŸ¥è­˜ä¸Šä¸‹æ–‡
    const knowledgeContext = await buildKnowledgeContext(knowledgeRoutes);
    
    // 3. ç”Ÿæˆ Agent System Prompt
    const systemPrompt = generateSystemPrompt({
        description,
        skills,
        knowledgeContext,
        knowledgeRoutes
    });
    
    // 4. å»ºç«‹ Agent
    const agent = await createAgent({
        name: extractAgentName(description),
        system_prompt: systemPrompt,
        knowledge_source_ids: knowledgeRoutes.map(r => r.id),
        skills
    });
    
    return NextResponse.json({ success: true, data: agent });
}
```

---

## ğŸ“Š æŠ€è¡“é–€æª»åˆ†æ

### 1. è¤‡é›œåº¦é–€æª»

- **å¤šå±¤æ¬¡ AI æ¨ç†**ï¼šéœ€è¦ç†è§£ AI Agent é‹ä½œæ©Ÿåˆ¶ã€Prompt Engineeringã€å¤šæ­¥é©Ÿæ¨ç†
- **èªç¾©åˆ†ææŠ€è¡“**ï¼šéœ€è¦ç†è§£ Embeddingã€å‘é‡ç›¸ä¼¼åº¦ã€èªç¾©æœå°‹
- **åœ–è­œæ¼”ç®—æ³•**ï¼šéœ€è¦ç†è§£çŸ¥è­˜åœ–è­œã€é—œè¯ç™¼ç¾ã€è·¯å¾‘æœå°‹
- **å“è³ªè©•ä¼°æ¨¡å‹**ï¼šéœ€è¦ç†è§£å¤šç¶­åº¦è©•ä¼°ã€æ¬Šé‡è¨­è¨ˆã€é–¾å€¼è¨­å®š

### 2. å…§å®¹é–€æª»

- **DIKW ç†è«–**ï¼šéœ€è¦æ·±åº¦ç†è§£ Data-Information-Knowledge-Wisdom å±¤ç´š
- **çŸ¥è­˜ç®¡ç†æœ€ä½³å¯¦è¸**ï¼šéœ€è¦ç†è§£ä¼æ¥­çŸ¥è­˜ç®¡ç†ã€æ–‡ä»¶æ²»ç†ã€ç‰ˆæœ¬æ§åˆ¶
- **ä¼æ¥­æ²»ç†æ¨™æº–**ï¼šéœ€è¦ç†è§£ Metadata Trinityã€å‘½åè¦ç¯„ã€åˆ†é¡æ¶æ§‹

### 3. å¯¦ä½œé–€æª»

- **ç³»çµ±æ•´åˆè¤‡é›œåº¦**ï¼šéœ€è¦æ•´åˆå¤šå€‹å­ç³»çµ±ï¼ˆç´¢å¼•ã€è·¯ç”±ã€å“è³ªã€åœ–è­œï¼‰
- **æ•ˆèƒ½å„ªåŒ–**ï¼šéœ€è¦è™•ç†å¤§è¦æ¨¡è³‡æ–™ã€å„ªåŒ–æŸ¥è©¢æ•ˆèƒ½
- **å¯æ“´å±•æ€§è¨­è¨ˆ**ï¼šéœ€è¦è¨­è¨ˆå¯æ“´å±•çš„æ¶æ§‹ã€æ”¯æ´æœªä¾†æ“´å……

---

## ğŸš€ å¯¦æ–½è·¯ç·šåœ–

### Phase 1: åŸºç¤å»ºè¨­ï¼ˆå·²å®Œæˆ âœ…ï¼‰

1. âœ… å¯¦ä½œå¤šç¶­åº¦çŸ¥è­˜ç´¢å¼•ç³»çµ±
2. âœ… å¯¦ä½œçŸ¥è­˜å“è³ªè©•ä¼°ç³»çµ±
3. âœ… å»ºç«‹çŸ¥è­˜åœ–è­œåŸºç¤æ¶æ§‹

### Phase 2: æ™ºèƒ½è·¯ç”±ï¼ˆå·²å®Œæˆ âœ…ï¼‰

1. âœ… å¯¦ä½œ Agent çŸ¥è­˜è·¯ç”±ç³»çµ±
2. âœ… æ•´åˆåˆ° Agent å»ºç«‹æµç¨‹
3. âœ… å„ªåŒ–è·¯ç”±æ¼”ç®—æ³•

### Phase 3: é€²éšåŠŸèƒ½ï¼ˆå·²å®Œæˆ âœ…ï¼‰

1. âœ… å¯¦ä½œèªç¾©çŸ¥è­˜åœ–è­œ
2. âœ… å¯¦ä½œçŸ¥è­˜æ¼”åŒ–è¿½è¹¤
3. âœ… å»ºç«‹çŸ¥è­˜å“è³ªç›£æ§å„€è¡¨æ¿

### Phase 4: v3.0 é€²éšå­ç³»çµ±ï¼ˆè¦åŠƒä¸­ ğŸ“‹ï¼‰

#### Phase 4.1: çŸ¥è­˜æ™‚æ•ˆæ€§ç®¡ç†ï¼ˆé è¨ˆ 2-3 é€±ï¼‰

| å„ªå…ˆåº | åŠŸèƒ½ | æè¿° | é ä¼°å·¥æ™‚ |
|-------|-----|------|---------|
| P0 | çŸ¥è­˜è¡°æ¸›æ¨¡å‹ | ä¾çŸ¥è­˜é¡å‹è¨ˆç®—ä¿é®®æœŸ | 3 å¤© |
| P0 | è¡°æ¸›é¡å‹è‡ªå‹•æ¨æ–· | AI åˆ†ææ–‡ä»¶é¡å‹ | 2 å¤© |
| P1 | è¡°æ¸›ç‹€æ…‹è¦–è¦ºåŒ– | åœ¨æ–‡ä»¶åˆ—è¡¨é¡¯ç¤ºè¡°æ¸›ç‹€æ…‹ | 2 å¤© |
| P1 | éæœŸé è­¦å„€è¡¨æ¿ | é›†ä¸­é¡¯ç¤ºå³å°‡éæœŸçŸ¥è­˜ | 3 å¤© |

#### Phase 4.2: åé¥‹å­¸ç¿’ç³»çµ±ï¼ˆé è¨ˆ 3-4 é€±ï¼‰

| å„ªå…ˆåº | åŠŸèƒ½ | æè¿° | é ä¼°å·¥æ™‚ |
|-------|-----|------|---------|
| P0 | é¡¯æ€§åé¥‹æ”¶é›† | ä½¿ç”¨è€…æŒ‰è®š/å€’è®š UI | 2 å¤© |
| P0 | åé¥‹è¨˜éŒ„èˆ‡çµ±è¨ˆ | è³‡æ–™åº«èˆ‡ API | 3 å¤© |
| P1 | éš±æ€§åé¥‹åˆ†æ | è¡Œç‚ºæ¨¡å¼æ¨æ–·æ»¿æ„åº¦ | 5 å¤© |
| P1 | å­¸ç¿’å¼•æ“ | å¾åé¥‹èª¿æ•´å“è³ªè©•åˆ† | 5 å¤© |
| P2 | æ¯æ—¥å­¸ç¿’å ±å‘Š | è‡ªå‹•åŒ–å­¸ç¿’åˆ†æ | 3 å¤© |

#### Phase 4.3: çŸ¥è­˜èšåˆç³»çµ±ï¼ˆé è¨ˆ 3-4 é€±ï¼‰

| å„ªå…ˆåº | åŠŸèƒ½ | æè¿° | é ä¼°å·¥æ™‚ |
|-------|-----|------|---------|
| P0 | æ¦‚å¿µæå– | å¾æ–‡ä»¶æå–æ ¸å¿ƒæ¦‚å¿µ | 3 å¤© |
| P0 | èšåˆå€™é¸ç™¼ç¾ | æ‰¾å‡ºå¯æ•´åˆçš„æ–‡ä»¶ç¾¤ | 3 å¤© |
| P1 | çŸ¥è­˜åˆæˆå¼•æ“ | AI æ•´åˆå¤šä»½æ–‡ä»¶ | 5 å¤© |
| P1 | è¡çªåµæ¸¬ | æ‰¾å‡ºçŸ¥è­˜çŸ›ç›¾ | 3 å¤© |
| P2 | çŸ¥è­˜å–®å…ƒç®¡ç† UI | CRUD ä»‹é¢ | 4 å¤© |

#### Phase 4.4: æ•ˆèƒ½å„ªåŒ–ï¼ˆé è¨ˆ 1-2 é€±ï¼‰

| å„ªå…ˆåº | åŠŸèƒ½ | æè¿° | é ä¼°å·¥æ™‚ |
|-------|-----|------|---------|
| P0 | HNSW ç´¢å¼•å»ºç«‹ | pgvector å‘é‡ç´¢å¼• | 1 å¤© |
| P0 | èªç¾©æœå°‹ RPC | å„ªåŒ–æœå°‹å‡½æ•¸ | 2 å¤© |
| P1 | æ‰¹é‡ç›¸ä¼¼åº¦è¨ˆç®— | ç”¨æ–¼åœ–è­œå»ºæ§‹ | 2 å¤© |
| P2 | æ•ˆèƒ½ç›£æ§ | æŸ¥è©¢æ™‚é–“è¿½è¹¤ | 2 å¤© |

#### Phase 4.5: ä¸»å‹•æ¨é€ç³»çµ±ï¼ˆé è¨ˆ 2-3 é€±ï¼‰

| å„ªå…ˆåº | åŠŸèƒ½ | æè¿° | é ä¼°å·¥æ™‚ |
|-------|-----|------|---------|
| P0 | é€šçŸ¥è³‡æ–™æ¨¡å‹ | è³‡æ–™åº«çµæ§‹ | 1 å¤© |
| P0 | çŸ¥è­˜æ›´æ–°è§¸ç™¼å™¨ | è®Šæ›´è‡ªå‹•é€šçŸ¥ | 2 å¤© |
| P0 | Agent å½±éŸ¿è¿½è¹¤ | çŸ¥è­˜-Agent é—œè¯ | 2 å¤© |
| P1 | é€šçŸ¥ä¸­å¿ƒ UI | ä½¿ç”¨è€…é€šçŸ¥ä»‹é¢ | 4 å¤© |
| P1 | éæœŸæª¢æŸ¥æ’ç¨‹ | å®šæ™‚æƒæ | 2 å¤© |
| P2 | Email é€šçŸ¥æ•´åˆ | ç·Šæ€¥é€šçŸ¥ç™¼é€ | 3 å¤© |

### Phase 5: å„ªåŒ–èˆ‡æ“´å±•ï¼ˆæŒçºŒé€²è¡Œä¸­ ğŸ”„ï¼‰

1. ğŸ”„ æŒçºŒå„ªåŒ–æ¼”ç®—æ³•
2. ğŸ”„ æ“´å±•çŸ¥è­˜æ¡†æ¶æ”¯æ´
3. ğŸ”„ å»ºç«‹çŸ¥è­˜æ²»ç†æœ€ä½³å¯¦è¸
4. ğŸ”„ å¤šèªè¨€æ”¯æ´
5. ğŸ”„ å¤šç§Ÿæˆ¶éš”é›¢å¼·åŒ–

---

## ğŸ“Š v3.0 æŠ€è¡“è½åœ°ç¸½è¦½

### ç³»çµ±æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        EAKAP v3.0 çŸ¥è­˜æ¶æ§‹å¼•æ“                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         å±•ç¤ºå±¤ (Presentation Layer)                   â”‚   â”‚
â”‚  â”‚                                                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚ é€šçŸ¥ä¸­å¿ƒ  â”‚ â”‚ çŸ¥è­˜åœ°åœ–  â”‚ â”‚ å“è³ªå„€è¡¨æ¿â”‚ â”‚ èšåˆç®¡ç†  â”‚ â”‚ åé¥‹æ”¶é›†  â”‚   â”‚   â”‚
â”‚  â”‚  â”‚    UI    â”‚ â”‚    UI    â”‚ â”‚    UI    â”‚ â”‚    UI    â”‚ â”‚    UI    â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         æœå‹™å±¤ (Service Layer)                        â”‚   â”‚
â”‚  â”‚                                                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚  â”‚  â”‚ v2.0 æ ¸å¿ƒæœå‹™  â”‚  â”‚ v3.0 é€²éšæœå‹™  â”‚  â”‚  æ’ç¨‹ä»»å‹™æœå‹™  â”‚            â”‚   â”‚
â”‚  â”‚  â”‚               â”‚  â”‚               â”‚  â”‚               â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ - å¤šç¶­åº¦ç´¢å¼•   â”‚  â”‚ - è¡°æ¸›è¨ˆç®—å™¨   â”‚  â”‚ - æ¯æ—¥è¡°æ¸›æ›´æ–° â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ - æ™ºèƒ½è·¯ç”±    â”‚  â”‚ - åé¥‹å­¸ç¿’å™¨   â”‚  â”‚ - éæœŸæª¢æŸ¥    â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ - å“è³ªè©•ä¼°    â”‚  â”‚ - èšåˆå¼•æ“    â”‚  â”‚ - å­¸ç¿’æ¨¡å‹è¨“ç·´ â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ - èªç¾©åœ–è­œ    â”‚  â”‚ - ANN æœå°‹    â”‚  â”‚ - è¡çªæƒæ    â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ - æ¼”åŒ–è¿½è¹¤    â”‚  â”‚ - æ¨é€å¼•æ“    â”‚  â”‚               â”‚            â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         è³‡æ–™å±¤ (Data Layer)                           â”‚   â”‚
â”‚  â”‚                                                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚                        PostgreSQL + pgvector                    â”‚ â”‚   â”‚
â”‚  â”‚  â”‚                                                                  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  æ ¸å¿ƒè¡¨                     â”‚  v3.0 æ–°å¢è¡¨                        â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ files                 â”‚  â”œâ”€â”€ knowledge_feedback_events     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ knowledge_instances   â”‚  â”œâ”€â”€ knowledge_units               â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ knowledge_frameworks  â”‚  â”œâ”€â”€ knowledge_unit_files          â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ knowledge_relations   â”‚  â”œâ”€â”€ knowledge_notifications       â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€ agents                â”‚  â””â”€â”€ agent_knowledge_sources       â”‚ â”‚   â”‚
â”‚  â”‚  â”‚                            â”‚                                     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  æ–°å¢æ¬„ä½ (files è¡¨)                                              â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ decay_type, decay_score, decay_status, valid_until         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ feedback_score, feedback_count, positive_ratio             â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€ needs_review, review_reason                                â”‚ â”‚   â”‚
â”‚  â”‚  â”‚                                                                  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  å‘é‡ç´¢å¼•                                                         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€ HNSW index on content_embedding (vector_cosine_ops)        â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è³‡æ–™æµæ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           v3.0 è³‡æ–™æµæ¶æ§‹                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                            â”‚
â”‚  1. çŸ¥è­˜è¡°æ¸›æµç¨‹                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ æ–‡ä»¶ä¸Šå‚³  â”‚ â†’ â”‚ AI æ¨æ–·  â”‚ â†’ â”‚ è¡°æ¸›è¨ˆç®—  â”‚ â†’ â”‚ ç‹€æ…‹æ›´æ–°  â”‚            â”‚
â”‚  â”‚          â”‚    â”‚ çŸ¥è­˜é¡å‹  â”‚    â”‚ è¡°æ¸›åˆ†æ•¸  â”‚    â”‚ è³‡æ–™åº«   â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                        â†“                   â”‚
â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                                              â”‚ æ¯æ—¥æ‰¹æ¬¡æ›´æ–°     â”‚         â”‚
â”‚                                              â”‚ (pg_cron)       â”‚         â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                            â”‚
â”‚  2. åé¥‹å­¸ç¿’æµç¨‹                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ ä½¿ç”¨è€…   â”‚ â†’ â”‚ åé¥‹æ”¶é›†  â”‚ â†’ â”‚ çµ±è¨ˆè¨ˆç®—  â”‚ â†’ â”‚ å“è³ªèª¿æ•´  â”‚            â”‚
â”‚  â”‚ ğŸ‘ğŸ‘    â”‚    â”‚ é¡¯æ€§+éš±æ€§ â”‚    â”‚ æ­£è² æ¯”ä¾‹  â”‚    â”‚ å­¸ç¿’å¼•æ“  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                        â†“                   â”‚
â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                                              â”‚ éœ€å¯©æŸ¥é€šçŸ¥      â”‚         â”‚
â”‚                                              â”‚ (çŸ¥è­˜æ“æœ‰è€…)    â”‚         â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                            â”‚
â”‚  3. çŸ¥è­˜èšåˆæµç¨‹                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ æ¦‚å¿µæå–  â”‚ â†’ â”‚ èšé¡åˆ†æ  â”‚ â†’ â”‚ è¡çªåµæ¸¬  â”‚ â†’ â”‚ çŸ¥è­˜åˆæˆ  â”‚            â”‚
â”‚  â”‚ (æ¯æ–‡ä»¶)  â”‚    â”‚ (ç›¸ä¼¼æ¦‚å¿µ)â”‚    â”‚ (çŸ›ç›¾è­˜åˆ¥)â”‚    â”‚ (AI æ•´åˆ) â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                        â†“                   â”‚
â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                                              â”‚ çŸ¥è­˜å–®å…ƒ        â”‚         â”‚
â”‚                                              â”‚ (å®Œæ•´çŸ¥è­˜è¦–è§’)   â”‚         â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                            â”‚
â”‚  4. ä¸»å‹•æ¨é€æµç¨‹                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ çŸ¥è­˜è®Šæ›´  â”‚ â†’ â”‚ å½±éŸ¿è©•ä¼°  â”‚ â†’ â”‚ é€šçŸ¥å»ºç«‹  â”‚ â†’ â”‚ å¤šç®¡é“ç™¼é€ â”‚            â”‚
â”‚  â”‚ (è§¸ç™¼å™¨)  â”‚    â”‚ (Agent)   â”‚    â”‚ (å„ªå…ˆç´š)  â”‚    â”‚ æ¨é€/Email â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚        â†‘                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                             â”‚
â”‚  â”‚ å®šæ™‚æƒæ  â”‚ â†’ éæœŸæª¢æŸ¥ã€è¡çªåµæ¸¬ã€å“è³ªä¸‹é™                                â”‚
â”‚  â”‚ (pg_cron)â”‚                                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                             â”‚
â”‚                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é·ç§»è…³æœ¬å½™ç¸½

```sql
-- ============================================================
-- EAKAP v3.0 è³‡æ–™åº«é·ç§»è…³æœ¬
-- ç‰ˆæœ¬: 3.0
-- æ—¥æœŸ: 2026-01-05
-- ============================================================

-- 1. ç¢ºä¿æ“´å±•å·²å•Ÿç”¨
CREATE EXTENSION IF NOT EXISTS vector;

-- 2. files è¡¨æ–°å¢æ¬„ä½
ALTER TABLE files ADD COLUMN IF NOT EXISTS decay_type VARCHAR(20) DEFAULT 'reference';
ALTER TABLE files ADD COLUMN IF NOT EXISTS decay_score DECIMAL(3,2) DEFAULT 1.0;
ALTER TABLE files ADD COLUMN IF NOT EXISTS decay_status VARCHAR(20) DEFAULT 'fresh';
ALTER TABLE files ADD COLUMN IF NOT EXISTS valid_until TIMESTAMPTZ DEFAULT NULL;
ALTER TABLE files ADD COLUMN IF NOT EXISTS feedback_score DECIMAL(3,2) DEFAULT 0.5;
ALTER TABLE files ADD COLUMN IF NOT EXISTS feedback_count INTEGER DEFAULT 0;
ALTER TABLE files ADD COLUMN IF NOT EXISTS positive_ratio DECIMAL(3,2) DEFAULT 0.5;
ALTER TABLE files ADD COLUMN IF NOT EXISTS last_feedback_at TIMESTAMPTZ;
ALTER TABLE files ADD COLUMN IF NOT EXISTS needs_review BOOLEAN DEFAULT FALSE;
ALTER TABLE files ADD COLUMN IF NOT EXISTS review_reason TEXT;

-- 3. agents è¡¨æ–°å¢æ¬„ä½
ALTER TABLE agents ADD COLUMN IF NOT EXISTS knowledge_status VARCHAR(30) DEFAULT 'up_to_date';
ALTER TABLE agents ADD COLUMN IF NOT EXISTS last_knowledge_alert TIMESTAMPTZ;
ALTER TABLE agents ADD COLUMN IF NOT EXISTS status_reason TEXT;

-- 4. å»ºç«‹ HNSW å‘é‡ç´¢å¼•ï¼ˆå–ä»£åŸæœ‰ç´¢å¼•ï¼‰
DROP INDEX IF EXISTS idx_files_embedding;
CREATE INDEX IF NOT EXISTS idx_files_embedding_hnsw 
    ON files 
    USING hnsw (content_embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

-- 5. å»ºç«‹æ–°è¡¨ï¼ˆè¦‹å„å­ç³»çµ±çš„ SQLï¼‰
-- ... (åé¥‹äº‹ä»¶è¡¨ã€çŸ¥è­˜å–®å…ƒè¡¨ã€é€šçŸ¥è¡¨ç­‰)

-- 6. å»ºç«‹ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_files_decay_status ON files(decay_status) WHERE gemini_state = 'SYNCED';

-- 7. åŸ·è¡Œå¾Œé©—è­‰
SELECT 
    (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'files' AND column_name = 'decay_type') as decay_type_added,
    (SELECT COUNT(*) FROM pg_indexes WHERE indexname = 'idx_files_embedding_hnsw') as hnsw_index_created;
```

---

## ğŸ“ˆ é æœŸæ•ˆç›Š

### 1. æŠ€è¡“å„ªå‹¢

| èƒ½åŠ› | v2.0 | v3.0 | æå‡å¹…åº¦ |
|-----|------|------|---------|
| çŸ¥è­˜æ™‚æ•ˆæ€§åˆ¤æ–· | ç²—ç•¥ï¼ˆä¾å¤©æ•¸ï¼‰ | ç²¾æº–ï¼ˆä¾é¡å‹è¡°æ¸›ï¼‰ | **æº–ç¢ºåº¦ +40%** |
| å“è³ªè©•ä¼°ä¾æ“š | éœæ…‹åˆ†æ | å‹•æ…‹åé¥‹å­¸ç¿’ | **æŒçºŒå„ªåŒ–** |
| çŸ¥è­˜å®Œæ•´æ€§ | å–®ä¸€æ–‡ä»¶è¦–è§’ | èšåˆçŸ¥è­˜å–®å…ƒ | **è¦†è“‹åº¦ +60%** |
| èªç¾©æœå°‹é€Ÿåº¦ | O(nÂ²) | O(n log n) | **100 å€æå‡** |
| çŸ¥è­˜ç•°å¸¸ç™¼ç¾ | è¢«å‹•ç­‰å¾… | ä¸»å‹•æ¨é€é€šçŸ¥ | **å³æ™‚éŸ¿æ‡‰** |

### 2. å•†æ¥­åƒ¹å€¼

- **ç«¶çˆ­å„ªå‹¢**ï¼šæŠ€è¡“é–€æª»æ¥µé«˜ï¼Œèåˆ AI æ¨ç†ã€çŸ¥è­˜ç®¡ç†ã€åœ–è­œæŠ€è¡“ï¼Œä¸æ˜“è¢«è¤‡è£½
- **å®¢æˆ¶åƒ¹å€¼**ï¼š
  - æ¸›å°‘å› éæ™‚çŸ¥è­˜å°è‡´çš„ Agent éŒ¯èª¤å›ç­”
  - è‡ªå‹•æ•´åˆåˆ†æ•£çŸ¥è­˜ï¼Œæå‡ Agent å›ç­”å®Œæ•´æ€§
  - ä¸»å‹•é è­¦æ©Ÿåˆ¶ï¼Œé¿å…é‡å¤§æ¥­å‹™å¤±èª¤
- **å¸‚å ´å®šä½**ï¼šä¼æ¥­ç´š AI çŸ¥è­˜æ¶æ§‹å¹³å°çš„æ¨™ç«¿ç”¢å“

### 3. é•·æœŸåƒ¹å€¼

- **çŸ¥è­˜è³‡ç”¢åŒ–**ï¼šå°‡ä¼æ¥­çŸ¥è­˜è½‰åŒ–ç‚ºå¯é‡åŒ–ã€å¯è¿½è¹¤ã€å¯æŒçºŒå„ªåŒ–çš„æ•¸ä½è³‡ç”¢
- **AI Agent ç”Ÿæ…‹**ï¼šå»ºç«‹å®Œæ•´çš„ AI Agent çŸ¥è­˜ç”Ÿå‘½é€±æœŸç®¡ç†é«”ç³»
- **æŒçºŒå„ªåŒ–**ï¼šé€éåé¥‹å­¸ç¿’è¿´è·¯ï¼Œç³»çµ±æœƒè¶Šç”¨è¶Šè°æ˜
- **é¢¨éšªæ§ç®¡**ï¼šä¸»å‹•æ¨é€æ©Ÿåˆ¶ç¢ºä¿é—œéµçŸ¥è­˜è®Šæ›´å³æ™‚åŒæ­¥

### 4. v3.0 ç‰¹æœ‰æ•ˆç›Š

| åŠŸèƒ½ | æ¥­å‹™å ´æ™¯ | é æœŸæ•ˆç›Š |
|-----|---------|---------|
| çŸ¥è­˜è¡°æ¸›æ¨¡å‹ | å ±åƒ¹ Agent ä½¿ç”¨ç”¢å“åƒ¹æ ¼è¡¨ | è‡ªå‹•æ¨™è¨˜éæœŸåƒ¹æ ¼ï¼Œé¿å…å ±éŒ¯åƒ¹ |
| åé¥‹å­¸ç¿’è¿´è·¯ | å®¢æœ Agent å›ç­”å®¢æˆ¶å•é¡Œ | è¶Šç”¨è¶Šæº–ï¼Œæ¸›å°‘äººå·¥ä»‹å…¥ |
| çŸ¥è­˜ç¢ç‰‡èšåˆ | é›¢è·æµç¨‹æ¶‰åŠ HR/IT/è²¡å‹™ | ä¸€æ¬¡è©¢å•ç²å¾—å®Œæ•´æµç¨‹ |
| é«˜æ•ˆèƒ½æœå°‹ | è¬ä»½æ–‡ä»¶ä¸­æ‰¾ç›¸é—œçŸ¥è­˜ | å¾åˆ†é˜ç´šé™è‡³ç§’ç´š |
| ä¸»å‹•æ¨é€ | æ”¿ç­–æ›´æ–°å½±éŸ¿å¤šå€‹ Agent | å³æ™‚é€šçŸ¥ï¼ŒåŒæ­¥æ›´æ–° |

---

## ğŸ“‹ é™„éŒ„ï¼šæŠ€è¡“è¦æ ¼ç¸½è¡¨

### è³‡æ–™åº«æ–°å¢çµæ§‹

| è¡¨å | ç”¨é€” | æ–°å¢/ä¿®æ”¹ |
|-----|-----|----------|
| `files` | æ ¸å¿ƒæ–‡ä»¶è¡¨ | æ–°å¢ 10 å€‹æ¬„ä½ |
| `agents` | Agent è¡¨ | æ–°å¢ 3 å€‹æ¬„ä½ |
| `knowledge_feedback_events` | åé¥‹äº‹ä»¶ | æ–°å¢è¡¨ |
| `knowledge_units` | çŸ¥è­˜å–®å…ƒ | æ–°å¢è¡¨ |
| `knowledge_unit_files` | å–®å…ƒ-æ–‡ä»¶é—œè¯ | æ–°å¢è¡¨ |
| `knowledge_notifications` | é€šçŸ¥ | æ–°å¢è¡¨ |
| `agent_knowledge_sources` | Agent-çŸ¥è­˜é—œè¯ | æ–°å¢è¡¨ |

### API ç«¯é»è¦åŠƒ

| ç«¯é» | æ–¹æ³• | ç”¨é€” |
|-----|-----|-----|
| `/api/knowledge/decay/calculate` | POST | è¨ˆç®—å–®ä¸€æ–‡ä»¶è¡°æ¸›åˆ†æ•¸ |
| `/api/knowledge/decay/batch-update` | POST | æ‰¹æ¬¡æ›´æ–°æ‰€æœ‰è¡°æ¸›åˆ†æ•¸ |
| `/api/knowledge/feedback` | POST | è¨˜éŒ„åé¥‹äº‹ä»¶ |
| `/api/knowledge/feedback/stats/:fileId` | GET | å–å¾—æ–‡ä»¶åé¥‹çµ±è¨ˆ |
| `/api/knowledge/units` | GET/POST | çŸ¥è­˜å–®å…ƒ CRUD |
| `/api/knowledge/units/discover` | POST | ç™¼ç¾å¯èšåˆçš„çŸ¥è­˜ |
| `/api/knowledge/search/semantic` | POST | é«˜æ•ˆèƒ½èªç¾©æœå°‹ |
| `/api/notifications` | GET | å–å¾—ä½¿ç”¨è€…é€šçŸ¥ |
| `/api/notifications/:id/resolve` | POST | è§£æ±ºé€šçŸ¥ |

### æ’ç¨‹ä»»å‹™

| ä»»å‹™ | é »ç‡ | ç”¨é€” |
|-----|-----|-----|
| `update_decay_scores` | æ¯æ—¥ 02:00 | æ›´æ–°æ‰€æœ‰æ–‡ä»¶è¡°æ¸›åˆ†æ•¸ |
| `check_approaching_expiry` | æ¯æ—¥ 08:00 | æª¢æŸ¥å³å°‡éæœŸçŸ¥è­˜ä¸¦ç™¼é€é€šçŸ¥ |
| `run_daily_learning` | æ¯æ—¥ 03:00 | åŸ·è¡Œåé¥‹å­¸ç¿’åˆ†æ |
| `detect_conflicts` | æ¯é€±ä¸€ | æƒæçŸ¥è­˜è¡çª |

---

**å ±å‘ŠçµæŸ**

**æ–‡ä»¶ç‰ˆæœ¬**: v3.0  
**æ›´æ–°æ—¥æœŸ**: 2026-01-05  
**ä½œè€…**: EAKAP ç³»çµ±æ¶æ§‹åœ˜éšŠ
