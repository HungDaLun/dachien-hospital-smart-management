# 超級管家（Super Assistant）完整設計文件

**版本**：v1.0  
**建立日期**：2026-01-17  
**設計目標**：定義超級管家的應用情境、技術架構與整合策略

---

## 📋 目錄

1. [核心設計原則](#核心設計原則)
2. [應用情境完整清單](#應用情境完整清單)
3. [行事曆系統設計](#行事曆系統設計)
4. [API 整合策略](#api-整合策略)
5. [系統設定架構](#系統設定架構)
6. [擴充性設計](#擴充性設計)
7. [語音整合設計](#語音整合設計)
8. [JARVIS 光球介面設計](#jarvis-光球介面設計)
9. [實作優先順序](#實作優先順序)

---

## 核心設計原則

### 原則 1：系統級 API，使用者零設定

**問題**：如果每個使用者都要申請 Google Calendar API、Email API、Line API... 太累人

**解決方案**：
- ✅ **系統管理員統一設定**：所有第三方 API 由 SUPER_ADMIN 在系統設定頁面統一配置
- ✅ **使用者只需授權**：使用者只需授權「允許系統存取我的 Google Calendar」，不需要申請 API Key
- ✅ **OAuth 流程**：使用 OAuth 2.0，使用者點擊「連接 Google Calendar」即可完成授權

### 原則 2：混合式行事曆架構

**問題**：應該用 Google Calendar 還是獨立行事曆？

**解決方案**：
- ✅ **主行事曆**：系統內建獨立行事曆（儲存在 Supabase）
- ✅ **同步選項**：使用者可選擇是否與 Google Calendar 雙向同步
- ✅ **最佳體驗**：系統內建行事曆提供完整功能，Google 同步為「加分項」

### 原則 3：情境驅動設計

先定義「使用者想要什麼」，再決定「需要什麼技術」

---

## 應用情境完整清單

### 類別 1：會議與排程管理

#### 情境 1.1：智能會議排程
**使用者說**：「幫我約下週三下午 2 點，跟業務部開會討論 Q1 目標」

**管家執行**：
1. 查詢業務部成員的可用時間
2. 檢查系統內建行事曆衝突
3. 發送 Line 訊息給所有參與者
4. Line 訊息包含「確認參加」按鈕
5. 收集回覆後，自動建立會議事件
6. 同步到 Google Calendar（如果使用者有授權）

**需要的 API**：
- ✅ Line Messaging API（系統級，已在 `system_settings`）
- ✅ Google Calendar API（OAuth，使用者授權）
- ✅ 系統內建行事曆（Supabase）

#### 情境 1.2：會議時間投票
**使用者說**：「幫我調查大家下週哪個時段有空，要開產品會議」

**管家執行**：
1. 發送 Line 訊息給指定成員
2. Line 訊息包含「時間選項按鈕」：
   ```
   📅 產品會議時間投票
   
   請選擇您有空的時段：
   [週一 14:00] [週一 16:00]
   [週二 10:00] [週二 14:00]
   [週三 14:00] [週三 16:00]
   ```
3. 收集所有回覆
4. 統計最適合的時間
5. 自動建立會議並通知所有人

**需要的 API**：
- ✅ Line Messaging API（系統級）
- ✅ Line Rich Menu / Template Message（系統級）

#### 情境 1.3：會議提醒
**使用者說**：「明天早上 9 點的會議，提前 15 分鐘提醒我」

**管家執行**：
1. 在系統行事曆建立提醒
2. 時間到時，透過 Line 推播提醒
3. 可選：同步到 Google Calendar 提醒

**需要的 API**：
- ✅ Line Push Notification（系統級）
- ✅ 系統排程系統（Cron Job）

---

### 類別 2：資訊查詢與報告

#### 情境 2.1：即時營運數據
**使用者說**：「今天營收多少？」

**管家執行**：
1. 查詢戰情室 API（`/api/war-room/kpi/financial`）
2. 回覆：「今天營收 42 萬 3 千元，比昨天多 8%」

**需要的 API**：
- ✅ 系統內建 API（無需外部）

#### 情境 2.2：知識庫查詢
**使用者說**：「我們公司的退貨政策是什麼？」

**管家執行**：
1. 搜尋知識庫（`/api/knowledge/search`）
2. 回覆：「根據知識庫文件，退貨政策如下...」

**需要的 API**：
- ✅ 系統內建 API（無需外部）

#### 情境 2.3：每日摘要
**使用者說**：「給我今天的營運摘要」

**管家執行**：
1. 彙整今日 KPI、風險、重要事件
2. 生成 Markdown 格式報告
3. 透過 Line 發送

**需要的 API**：
- ✅ Line Messaging API（系統級）
- ✅ 系統內建 API

---

### 類別 3：任務委派與執行

#### 情境 3.1：文件生成與寄送
**使用者說**：「幫我把上個月的財務報表整理成 PDF，下週一早上 8 點寄給王董事」

**管家執行**：
1. 查詢財務數據（戰情室 API）
2. 生成 PDF 報告
3. 排程下週一 8:00 執行
4. 時間到時，透過 Email 寄送
5. 完成後通知使用者

**需要的 API**：
- ✅ Email API（Resend / SendGrid，系統級，已在 `system_settings`）
- ✅ PDF 生成（系統內建）
- ✅ 系統排程系統

#### 情境 3.2：資料彙整
**使用者說**：「幫我整理這個月各部門的 KPI，做成簡報」

**管家執行**：
1. 查詢各部門 KPI 數據
2. 生成簡報（Markdown / PDF）
3. 儲存到系統
4. 通知使用者完成

**需要的 API**：
- ✅ 系統內建 API

#### 情境 3.3：定期報告
**使用者說**：「每週一早上 9 點，自動寄送上週營運摘要給所有主管」

**管家執行**：
1. 建立排程任務（每週一 9:00）
2. 執行時：
   - 查詢上週數據
   - 生成摘要報告
   - 寄送 Email 給主管名單
3. 完成後記錄

**需要的 API**：
- ✅ Email API（系統級）
- ✅ 系統排程系統

---

### 類別 4：主動通知與預警

#### 情境 4.1：風險預警
**系統自動**：偵測到「客戶 A 付款逾期 3 天」

**管家執行**：
1. 透過 Line 推播通知
2. 提供建議行動：「要我發催款通知嗎？」
3. 使用者回覆「好」，自動執行

**需要的 API**：
- ✅ Line Push Notification（系統級）
- ✅ Email API（系統級）

#### 情境 4.2：異常偵測
**系統自動**：偵測到「今日營收比平均低 30%」

**管家執行**：
1. 分析可能原因
2. 透過 Line 推播：「今日營收異常，可能原因：週末效應 / 系統問題」
3. 提供查詢選項

**需要的 API**：
- ✅ Line Push Notification（系統級）

#### 情境 4.3：每日早安簡報
**系統自動**：每天早上 7:00

**管家執行**：
1. 彙整昨日重點、今日待辦
2. 透過 Line 推播：「早安！今日重點：...」

**需要的 API**：
- ✅ Line Push Notification（系統級）

---

### 類別 5：外部系統整合

#### 情境 5.1：Gmail 整合（未來）
**使用者說**：「幫我回覆客戶 A 的 Email，說我們會在下週交貨」

**管家執行**：
1. 透過 Gmail API 查詢未讀郵件
2. 找到客戶 A 的郵件
3. 生成回覆內容
4. 透過 Gmail API 發送

**需要的 API**：
- ✅ Gmail API（OAuth，使用者授權）
- ⚠️ 需要 MCP Server 整合

#### 情境 5.2：Slack 整合（未來）
**使用者說**：「把今天的營運摘要發到 Slack #general 頻道」

**管家執行**：
1. 生成摘要
2. 透過 Slack API 發送到指定頻道

**需要的 API**：
- ✅ Slack Webhook / API（系統級或 OAuth）

---

## 行事曆系統設計

### 架構決策：混合式行事曆

```
┌─────────────────────────────────────────────────────────────┐
│                    混合式行事曆架構                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           系統內建行事曆（主系統）                      │  │
│  │  • 儲存在 Supabase (calendar_events 表)               │  │
│  │  • 完整功能：建立、查詢、更新、刪除                    │  │
│  │  • 權限控制：部門、標籤限制                            │  │
│  │  • 會議參與者管理                                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                          │                                   │
│                          │ 雙向同步（可選）                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │         Google Calendar（同步層）                      │  │
│  │  • OAuth 2.0 授權（使用者層級）                        │  │
│  │  • 自動同步：系統 → Google                             │  │
│  │  • 自動同步：Google → 系統（可選）                     │  │
│  │  • 僅同步使用者有權限的事件                            │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 資料模型設計

```sql
-- 行事曆事件表（系統內建）
CREATE TABLE calendar_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 基本資訊
    title TEXT NOT NULL,
    description TEXT,
    location TEXT,
    
    -- 時間
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    timezone TEXT DEFAULT 'Asia/Taipei',
    is_all_day BOOLEAN DEFAULT FALSE,
    
    -- 參與者
    organizer_id UUID REFERENCES user_profiles(id) NOT NULL,
    participants JSONB DEFAULT '[]', -- [{user_id, status: 'pending'|'accepted'|'declined', responded_at}]
    
    -- 權限
    department_id UUID REFERENCES departments(id),
    visibility TEXT DEFAULT 'department', -- 'private', 'department', 'company'
    
    -- 同步狀態
    google_calendar_id TEXT, -- Google Calendar Event ID（如果已同步）
    google_sync_enabled BOOLEAN DEFAULT FALSE,
    last_synced_at TIMESTAMPTZ,
    
    -- 狀態
    status TEXT DEFAULT 'scheduled', -- 'scheduled', 'in_progress', 'completed', 'cancelled'
    
    -- 提醒
    reminders JSONB DEFAULT '[]', -- [{type: 'line'|'email', minutes_before: 15}]
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Google Calendar 授權表（使用者層級）
CREATE TABLE google_calendar_authorizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) UNIQUE NOT NULL,
    
    -- OAuth Token
    access_token TEXT NOT NULL, -- 加密儲存
    refresh_token TEXT, -- 加密儲存
    token_expires_at TIMESTAMPTZ,
    
    -- 同步設定
    sync_enabled BOOLEAN DEFAULT TRUE,
    sync_direction TEXT DEFAULT 'bidirectional', -- 'to_google', 'from_google', 'bidirectional'
    default_calendar_id TEXT, -- Google Calendar ID
    
    -- 狀態
    is_active BOOLEAN DEFAULT TRUE,
    last_sync_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 為什麼選擇混合式架構？

| 方案 | 優點 | 缺點 | 適用場景 |
|-----|------|------|---------|
| **純系統內建** | 完全控制、無需授權 | 無法與外部行事曆整合 | 封閉企業環境 |
| **純 Google Calendar** | 與外部整合好 | 每個人都要授權、依賴 Google | 全公司都用 Google |
| **混合式（推薦）** | 兩者優點兼具 | 需要同步邏輯 | ✅ 最佳方案 |

### 同步策略

```typescript
// lib/calendar/sync-strategy.ts

/**
 * 行事曆同步策略
 */
export class CalendarSyncStrategy {
    /**
     * 系統 → Google 同步
     * 當系統內建立事件時，如果使用者有授權，自動同步到 Google
     */
    async syncToGoogle(eventId: string): Promise<void> {
        const event = await this.getEvent(eventId);
        const organizer = await this.getUser(event.organizer_id);
        
        // 檢查是否有 Google 授權
        const auth = await this.getGoogleAuth(organizer.id);
        if (!auth || !auth.sync_enabled) {
            return; // 不同步
        }
        
        // 建立 Google Calendar 事件
        const googleEvent = await this.createGoogleEvent(auth, event);
        
        // 更新系統事件，記錄 Google ID
        await this.updateEvent(eventId, {
            google_calendar_id: googleEvent.id,
            last_synced_at: new Date()
        });
    }
    
    /**
     * Google → 系統同步（可選）
     * 定期同步 Google Calendar 的新事件到系統
     */
    async syncFromGoogle(userId: string): Promise<void> {
        const auth = await this.getGoogleAuth(userId);
        if (!auth || auth.sync_direction !== 'bidirectional') {
            return; // 不從 Google 同步
        }
        
        // 查詢 Google Calendar 新事件
        const googleEvents = await this.fetchGoogleEvents(auth);
        
        // 比對系統事件，新增不存在的
        for (const googleEvent of googleEvents) {
            const existing = await this.findEventByGoogleId(googleEvent.id);
            if (!existing) {
                await this.createEventFromGoogle(googleEvent, userId);
            }
        }
    }
}
```

---

## API 整合策略

### 策略 1：系統級 API（由 SUPER_ADMIN 統一設定）

**適用場景**：所有使用者共用同一個 API Key

| API | 用途 | 設定位置 | 範例 |
|-----|------|---------|------|
| **Line Messaging API** | 發送 Line 訊息、推播 | `system_settings.line_channel_token` | ✅ 已實作 |
| **Email API (Resend)** | 發送 Email | `system_settings.resend_api_key` | ✅ 已實作 |
| **Email API (SendGrid)** | 發送 Email（備選） | `system_settings.sendgrid_api_key` | ✅ 已實作 |
| **Slack Webhook** | 發送 Slack 訊息 | `system_settings.slack_webhook_url` | ✅ 已實作 |

**優點**：
- ✅ 使用者零設定
- ✅ 統一管理
- ✅ 成本控制（共用配額）

**缺點**：
- ⚠️ 所有訊息都從同一個 Line Bot 發送（可透過訊息內容區分）

### 策略 2：OAuth 授權（使用者層級授權）

**適用場景**：需要存取使用者個人資料的服務

| API | 用途 | 授權方式 | 儲存位置 |
|-----|------|---------|---------|
| **Google Calendar** | 同步行事曆 | OAuth 2.0 | `google_calendar_authorizations` |
| **Gmail** | 讀取/發送郵件 | OAuth 2.0 | `gmail_authorizations`（未來） |
| **Google Drive** | 存取檔案 | OAuth 2.0 | `google_drive_authorizations`（未來） |

**優點**：
- ✅ 使用者只需點擊「連接 Google Calendar」即可
- ✅ 不需要申請 API Key
- ✅ 權限可控（使用者可隨時撤銷）

**缺點**：
- ⚠️ 需要實作 OAuth 流程
- ⚠️ 需要處理 Token 刷新

### 策略 3：混合模式（系統級設定 + 使用者授權）

**最佳實踐**：
- 系統級 API：Line、Email、Slack（所有使用者共用）
- OAuth 授權：Google Calendar、Gmail（個人資料）

---

## 系統設定架構

### 現有設定擴充

系統已經有 `system_settings` 表，我們需要新增：

```sql
-- 新增超級管家相關設定
INSERT INTO system_settings (setting_key, setting_value, is_encrypted, description) VALUES
    -- Google OAuth（系統級設定，用於 OAuth 流程）
    ('google_oauth_client_id', NULL, FALSE, 'Google OAuth Client ID（用於 Calendar/Drive 授權）'),
    ('google_oauth_client_secret', NULL, TRUE, 'Google OAuth Client Secret（加密）'),
    ('google_oauth_redirect_uri', NULL, FALSE, 'Google OAuth Redirect URI'),
    
    -- 行事曆設定
    ('calendar_default_timezone', 'Asia/Taipei', FALSE, '預設時區'),
    ('calendar_sync_interval_minutes', '15', FALSE, 'Google Calendar 同步間隔（分鐘）'),
    
    -- 通知設定
    ('notification_line_enabled', 'true', FALSE, '是否啟用 Line 通知'),
    ('notification_email_enabled', 'true', FALSE, '是否啟用 Email 通知'),
    ('notification_daily_briefing_time', '07:00', FALSE, '每日簡報發送時間')
ON CONFLICT (setting_key) DO NOTHING;
```

### 使用者授權管理

```sql
-- 使用者授權表（擴充現有設計）
CREATE TABLE user_authorizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) NOT NULL,
    
    -- 授權類型
    provider TEXT NOT NULL, -- 'google_calendar', 'gmail', 'google_drive'
    provider_account_id TEXT, -- Google Account ID
    
    -- OAuth Token
    access_token TEXT NOT NULL, -- 加密儲存
    refresh_token TEXT, -- 加密儲存
    token_expires_at TIMESTAMPTZ,
    
    -- 授權範圍
    scopes TEXT[], -- ['https://www.googleapis.com/auth/calendar']
    
    -- 狀態
    is_active BOOLEAN DEFAULT TRUE,
    authorized_at TIMESTAMPTZ DEFAULT NOW(),
    last_used_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(user_id, provider)
);
```

---

## 擴充性設計

### 設計原則：可插拔架構

超級管家採用**可插拔架構**，未來新增功能只需：
1. 註冊工具到 `tools_registry`
2. 或連接 MCP Server
3. 或新增 API 整合

**無需修改核心程式碼**。

### 擴充方式 1：工具註冊表（Tools Registry）

**現有機制**：系統已有 `tools_registry` 表，可動態註冊工具

```typescript
// 新增工具範例：Gmail 整合
INSERT INTO tools_registry (
    name,
    display_name,
    description,
    category,
    function_declaration,
    requires_api_key
) VALUES (
    'send_gmail',
    '發送 Gmail',
    '透過 Gmail API 發送郵件',
    'communication',
    '{
        "name": "send_gmail",
        "description": "發送 Gmail 郵件",
        "parameters": {
            "type": "object",
            "properties": {
                "to": {"type": "string"},
                "subject": {"type": "string"},
                "body": {"type": "string"}
            }
        }
    }'::jsonb,
    FALSE  -- 使用 OAuth，不需要 API Key
);
```

**優點**：
- ✅ 動態載入，無需重啟系統
- ✅ 統一管理（在系統設定頁面）
- ✅ 權限控制（可設定哪些 Agent 可用）

### 擴充方式 2：MCP Server 整合

**MCP (Model Context Protocol)**：Anthropic 提出的標準協議，用於連接外部服務

```typescript
// lib/executive-assistant/mcp-integration.ts

/**
 * MCP Server 整合
 * 支援連接外部 MCP Server（Gmail、Slack、Notion 等）
 */
export class MCPIntegration {
    /**
     * 註冊 MCP Server
     */
    async registerMCPServer(config: {
        name: string;
        server_url: string;
        api_key?: string;
        capabilities: string[];
    }): Promise<void> {
        // 儲存到 system_settings 或 mcp_servers 表
    }
    
    /**
     * 查詢可用的 MCP 工具
     */
    async listMCPTools(): Promise<MCPTool[]> {
        // 從所有已註冊的 MCP Server 查詢工具
    }
    
    /**
     * 執行 MCP 工具
     */
    async executeMCPTool(
        serverName: string,
        toolName: string,
        args: Record<string, any>
    ): Promise<any> {
        // 透過 MCP Protocol 呼叫工具
    }
}
```

**資料模型擴充**：

```sql
-- MCP Server 註冊表
CREATE TABLE mcp_servers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 基本資訊
    name TEXT NOT NULL UNIQUE, -- 'gmail', 'slack', 'notion'
    display_name TEXT NOT NULL,
    description TEXT,
    
    -- 連接資訊
    server_url TEXT NOT NULL, -- MCP Server URL
    server_type TEXT DEFAULT 'http', -- 'http', 'websocket', 'stdio'
    api_key TEXT, -- 加密儲存（如果需要）
    
    -- 能力
    capabilities JSONB DEFAULT '[]', -- ['read_email', 'send_email']
    
    -- 狀態
    is_active BOOLEAN DEFAULT TRUE,
    last_health_check TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**使用範例**：

```typescript
// 未來：Gmail MCP Server 整合
// 1. 管理員在系統設定頁面註冊 Gmail MCP Server
// 2. 系統自動發現可用工具：read_email, send_email, search_email
// 3. Orchestrator Agent 自動可使用這些工具
// 4. 使用者說「幫我回覆客戶 A 的郵件」，系統自動使用 MCP 工具
```

### 擴充方式 3：自訂 API 整合

**適用場景**：企業內部系統、第三方 SaaS

```typescript
// lib/executive-assistant/custom-api-integration.ts

/**
 * 自訂 API 整合
 * 允許管理員註冊自訂 API 端點
 */
export class CustomAPIIntegration {
    /**
     * 註冊自訂 API
     */
    async registerCustomAPI(config: {
        name: string;
        base_url: string;
        auth_type: 'bearer' | 'api_key' | 'oauth';
        auth_config: Record<string, any>;
        endpoints: Array<{
            name: string;
            method: 'GET' | 'POST' | 'PUT' | 'DELETE';
            path: string;
            description: string;
            parameters: JSONSchema;
        }>;
    }): Promise<void> {
        // 儲存到 custom_apis 表
        // 自動生成 Function Declaration
        // 註冊到 tools_registry
    }
}
```

**資料模型**：

```sql
-- 自訂 API 註冊表
CREATE TABLE custom_apis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 基本資訊
    name TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    
    -- API 設定
    base_url TEXT NOT NULL,
    auth_type TEXT NOT NULL, -- 'bearer', 'api_key', 'oauth'
    auth_config JSONB, -- 認證設定（加密）
    
    -- 端點定義
    endpoints JSONB NOT NULL, -- [{name, method, path, description, parameters}]
    
    -- 狀態
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 擴充流程圖

```
┌─────────────────────────────────────────────────────────────┐
│                    功能擴充流程                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  方式 1: 工具註冊表                                           │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  1. 開發工具實作 (lib/tools/your-tool.ts)             │  │
│  │  2. 插入 tools_registry 表                           │  │
│  │  3. 系統自動載入，Orchestrator 可使用                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  方式 2: MCP Server                                          │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  1. 部署/連接 MCP Server                             │  │
│  │  2. 在系統設定頁面註冊                                │  │
│  │  3. 系統自動發現工具，註冊到 tools_registry          │  │
│  │  4. Orchestrator 自動可使用                          │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  方式 3: 自訂 API                                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  1. 在系統設定頁面註冊 API（URL、認證、端點）         │  │
│  │  2. 系統自動生成 Function Declaration                │  │
│  │  3. 註冊到 tools_registry                             │  │
│  │  4. Orchestrator 自動可使用                          │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 語音整合設計

### 整合架構：統一入口，多模態支援

**核心設計**：超級管家支援**文字、語音、Line** 三種入口，共用同一個 Orchestrator Agent

```
┌─────────────────────────────────────────────────────────────┐
│                    超級管家統一架構                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                │
│  │  文字     │  │  語音     │  │  Line    │                │
│  │  Web UI  │  │  Voice UI │  │  Bot     │                │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘                │
│       │             │              │                       │
│       └─────────────┴──────────────┘                       │
│                      │                                       │
│                      ▼                                       │
│         ┌─────────────────────────┐                         │
│         │  統一訊息 Gateway        │                         │
│         │  (Unified Message       │                         │
│         │   Gateway)               │                         │
│         └───────────┬─────────────┘                         │
│                     │                                       │
│                     ▼                                       │
│         ┌─────────────────────────┐                         │
│         │  Orchestrator Agent      │                         │
│         │  (意圖識別、任務分解)    │                         │
│         └───────────┬─────────────┘                         │
│                     │                                       │
│                     ▼                                       │
│         ┌─────────────────────────┐                         │
│         │  工具執行層              │                         │
│         │  (Tools / MCP / API)    │                         │
│         └─────────────────────────┘                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 語音整合實作

**參考文件**：`05.VOICE_AI_IMPLEMENTATION_PLAN_C.md`

**整合方式**：

```typescript
// lib/executive-assistant/voice-integration.ts

/**
 * 語音整合
 * 連接 LiveKit Agent，將語音轉文字後送入統一 Gateway
 */
export class VoiceIntegration {
    /**
     * 處理語音輸入
     */
    async handleVoiceInput(
        audioStream: AudioStream,
        userId: string,
        agentId: string
    ): Promise<void> {
        // 1. 透過 LiveKit Agent 進行 STT
        const text = await this.speechToText(audioStream);
        
        // 2. 送入統一訊息 Gateway（與文字入口相同）
        await this.unifiedGateway.processMessage({
            source: 'voice',
            text,
            userId,
            agentId,
            metadata: {
                audio_duration: audioStream.duration,
                confidence: text.confidence
            }
        });
    }
    
    /**
     * 處理語音輸出
     */
    async handleVoiceOutput(
        response: AssistantResponse,
        audioStream: AudioStream
    ): Promise<void> {
        // 1. 透過 LiveKit Agent 進行 TTS
        const audio = await this.textToSpeech(response.text);
        
        // 2. 串流回前端
        await audioStream.write(audio);
    }
}
```

### 前端整合：JARVIS 光球介面

**點擊「超級管家」按鈕後，顯示 JARVIS 風格介面**

```typescript
// app/[locale]/(dashboard)/super-assistant/page.tsx

'use client';

import { useState } from 'react';
import { LiveKitRoom } from '@livekit/components-react';
import VoiceOrb from './components/VoiceOrb';
import TextChat from './components/TextChat';
import { useVoiceAssistant } from '@livekit/components-react';

export default function SuperAssistantPage() {
    const [mode, setMode] = useState<'voice' | 'text'>('voice');
    const [isConnected, setIsConnected] = useState(false);
    
    return (
        <div className="min-h-screen bg-gradient-to-b from-slate-900 via-slate-950 to-black">
            {/* JARVIS 光球介面 */}
            {mode === 'voice' && (
                <LiveKitRoom
                    serverUrl={process.env.NEXT_PUBLIC_LIVEKIT_URL!}
                    token={voiceToken}
                    connect={isConnected}
                    audio={true}
                    video={false}
                >
                    <VoiceAssistantUI />
                </LiveKitRoom>
            )}
            
            {/* 文字對話介面（可切換） */}
            {mode === 'text' && (
                <TextChat />
            )}
            
            {/* 模式切換按鈕 */}
            <ModeToggle mode={mode} onModeChange={setMode} />
        </div>
    );
}
```

**參考設計**：`06.JOBS_STYLE_AI_ASSISTANT_DESIGN.md` 的光球設計

---

## JARVIS 光球介面設計

### 設計理念：極致簡約、零學習曲線

**參考文件**：`06.JOBS_STYLE_AI_ASSISTANT_DESIGN.md`

### 主介面設計

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  背景：深色漸層                                                   │
│  從 #0f172a (slate-900) 漸變到 #000000                           │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │                    光球區域                              │    │
│  │                    佔畫面 60%                            │    │
│  │                                                         │    │
│  │              ╭────────────────────╮                    │    │
│  │             ╱                      ╲                   │    │
│  │            │                        │                  │    │
│  │            │      ◉        ◉       │     直徑：200px  │    │
│  │            │          ⌒           │                  │    │
│  │             ╲                      ╱                   │    │
│  │              ╰────────────────────╯                    │    │
│  │                                                         │    │
│  │           漸層：primary-500 → purple-500                │    │
│  │           透明度：0.8                                    │    │
│  │           模糊：backdrop-blur-xl                        │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    對話文字區                             │    │
│  │                                                         │    │
│  │  「 您好，我是小智。有什麼我可以幫您的？ 」                │    │
│  │                                                         │    │
│  │  字體：Inter / Noto Sans TC                              │    │
│  │  大小：24px                                              │    │
│  │  顏色：#ffffff 80%                                       │    │
│  │  動畫：打字機效果，每字 50ms                              │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    狀態提示區                             │    │
│  │                                                         │    │
│  │  🎤 正在聆聽...                                          │    │
│  │                                                         │    │
│  │  字體大小：14px                                          │    │
│  │  顏色：#94a3b8 (slate-400)                               │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    控制區                                │    │
│  │                                                         │    │
│  │  [🎤 語音]  [⌨️ 文字]  [📋 任務]  [⚙️ 設定]              │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 光球狀態設計

| 狀態 | 顏色 | 動畫 | 說明 |
|-----|------|------|------|
| **待機** | 藍紫漸層 | 緩慢呼吸（3s 週期） | 等待使用者說話 |
| **聆聽中** | 綠色 (#22c55e) | 快速脈動（0.5s 週期） | 正在接收語音 |
| **收到指令** | 白色閃光 | 單次閃爍（0.3s） | 確認收到 |
| **處理中** | 藍色 (#3b82f6) | 順時針旋轉 | AI 思考中 |
| **說話中** | 紫色 (#a855f7) | 隨音量律動 | AI 回答中 |
| **錯誤** | 紅色 (#ef4444) | 搖晃 | 發生錯誤 |

### 整合到超級管家

**入口設計**：

```typescript
// components/executive-assistant/SuperAssistantButton.tsx

'use client';

import { useState } from 'react';
import { Sparkles } from 'lucide-react';
import SuperAssistantModal from './SuperAssistantModal';

export default function SuperAssistantButton() {
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        <>
            <button
                onClick={() => setIsOpen(true)}
                className="group px-4 py-2 rounded-full bg-gradient-to-r from-primary-500/10 to-purple-500/10 border border-primary-500/20 text-primary-400 text-xs font-bold flex items-center gap-2 hover:bg-primary-500/20 hover:border-primary-500/40 hover:text-primary-300 transition-all cursor-pointer shadow-[0_0_15px_rgba(99,102,241,0.1)] hover:shadow-[0_0_20px_rgba(99,102,241,0.2)]"
            >
                <Sparkles size={14} className="text-primary-400" />
                超級管家
            </button>
            
            {isOpen && (
                <SuperAssistantModal onClose={() => setIsOpen(false)} />
            )}
        </>
    );
}
```

**Modal 內容**：

```typescript
// components/executive-assistant/SuperAssistantModal.tsx

'use client';

import { useState } from 'react';
import { X } from 'lucide-react';
import VoiceOrb from './VoiceOrb';
import TextChat from './TextChat';

export default function SuperAssistantModal({ onClose }: { onClose: () => void }) {
    const [mode, setMode] = useState<'voice' | 'text'>('voice');
    
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
            <div className="relative w-full h-full max-w-6xl max-h-[90vh] bg-gradient-to-b from-slate-900 via-slate-950 to-black rounded-3xl overflow-hidden">
                {/* 關閉按鈕 */}
                <button
                    onClick={onClose}
                    className="absolute top-4 right-4 z-10 p-2 rounded-full bg-white/10 hover:bg-white/20 transition-colors"
                >
                    <X size={20} className="text-white" />
                </button>
                
                {/* 主內容 */}
                <div className="h-full flex flex-col">
                    {mode === 'voice' ? (
                        <VoiceOrb onModeChange={setMode} />
                    ) : (
                        <TextChat onModeChange={setMode} />
                    )}
                </div>
            </div>
        </div>
    );
}
```

### 設計原則（參考 06.JOBS_STYLE_AI_ASSISTANT_DESIGN.md）

1. **消滅「開始對話」按鈕**：頁面載入即自動連接
2. **「秒回」感知優化**：視覺回饋在 100ms 內出現
3. **說人話**：回答簡潔有力，3-5 句話內
4. **無形的任務追蹤**：AI 主動回報完成，不需要使用者查看
5. **漸進式揭露**：功能隨使用次數逐步提示

---

## 實作優先順序

### Phase 1：核心功能（2 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P0 | 統一訊息 Gateway | 處理所有入口訊息（文字/語音/Line） | 2 天 |
| P0 | Orchestrator Agent | 意圖識別、任務分解 | 3 天 |
| P0 | 系統內建行事曆 | 基礎 CRUD、參與者管理 | 3 天 |
| P0 | Line Bot 整合 | Webhook、雙向對話 | 2 天 |
| P0 | JARVIS 光球介面 | 前端 UI、光球動畫、模式切換 | 3 天 |
| P1 | 任務排程系統 | 異步任務執行 | 2 天 |
| P1 | 語音整合預留 | 連接 LiveKit Agent 的介面設計 | 1 天 |

### Phase 2：會議排程（1 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P0 | 會議時間投票 | Line Template Message | 2 天 |
| P0 | 智能會議排程 | 查詢可用時間、自動建立 | 2 天 |
| P1 | 會議提醒 | 排程提醒、Line 推播 | 1 天 |

### Phase 3：Google Calendar 整合（1 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P0 | Google OAuth 流程 | 授權頁面、Token 管理 | 2 天 |
| P0 | 系統 → Google 同步 | 自動同步新事件 | 2 天 |
| P1 | Google → 系統同步 | 定期同步（可選） | 1 天 |

### Phase 4：語音整合（1.5 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P0 | LiveKit Agent 整合 | 連接語音處理 Pipeline | 3 天 |
| P0 | 語音 → Gateway | STT 後送入統一 Gateway | 2 天 |
| P0 | Gateway → 語音 | TTS 回應串流回前端 | 2 天 |
| P1 | 光球音訊視覺化 | 隨音量律動效果 | 1 天 |

### Phase 5：進階功能（2 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P1 | 文件生成與寄送 | PDF 生成、Email 寄送 | 3 天 |
| P1 | 定期報告 | 排程任務、自動執行 | 2 天 |
| P1 | 主動通知系統 | 風險預警、異常偵測 | 2 天 |
| P2 | 每日早安簡報 | 自動生成、Line 推播 | 1 天 |

### Phase 6：擴充性實作（1 週）

| 優先級 | 功能 | 說明 | 預估工時 |
|-------|------|------|---------|
| P1 | MCP Server 整合 | 註冊、發現、執行 MCP 工具 | 3 天 |
| P1 | 自訂 API 註冊 | 管理員可註冊自訂 API | 2 天 |
| P2 | 工具市場 UI | 瀏覽、安裝第三方工具 | 2 天 |

---

## 總結建議

### 1. 行事曆系統
✅ **採用混合式架構**：
- 系統內建行事曆為主（完整功能）
- Google Calendar 同步為選項（OAuth 授權）

### 2. API 整合
✅ **系統級 API**：Line、Email、Slack（SUPER_ADMIN 統一設定）  
✅ **OAuth 授權**：Google Calendar、Gmail（使用者點擊授權）

### 3. 應用情境
✅ **先實作核心情境**：
- 會議排程與投票
- 資訊查詢
- 任務委派

### 4. 使用者體驗
✅ **零設定原則**：
- 系統級 API 由管理員設定
- 個人授權只需點擊「連接」按鈕
- 不需要申請 API Key

### 5. 擴充性
✅ **可插拔架構**：
- 工具註冊表：動態註冊新工具
- MCP Server：連接外部服務（Gmail、Slack 等）
- 自訂 API：管理員可註冊企業內部系統

### 6. 多模態整合
✅ **統一入口設計**：
- 文字、語音、Line 共用同一個 Orchestrator Agent
- JARVIS 光球介面：點擊「超級管家」即顯示
- 可切換語音/文字模式

---

## 技術架構總覽

```
┌─────────────────────────────────────────────────────────────┐
│                    超級管家完整架構                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  入口層 (Input Layer)                                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                │
│  │  文字     │  │  語音     │  │  Line    │                │
│  │  Web UI  │  │  Voice UI │  │  Bot     │                │
│  │ (JARVIS) │  │ (LiveKit) │  │ (Webhook)│                │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘                │
│       │             │              │                       │
│       └─────────────┴──────────────┘                       │
│                      │                                       │
│                      ▼                                       │
│  統一訊息 Gateway (Unified Message Gateway)                 │
│  • 格式轉換                                                  │
│  • 路由分發                                                  │
│  • 來源標記                                                  │
│                      │                                       │
│                      ▼                                       │
│  Orchestrator Agent (總管大腦)                               │
│  • 意圖識別 (Query / Action / Scheduled)                     │
│  • 任務分解                                                  │
│  • 執行規劃                                                  │
│  • 結果彙整                                                  │
│                      │                                       │
│                      ▼                                       │
│  工具執行層 (Execution Layer)                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                │
│  │  Tools   │  │  MCP     │  │  Custom  │                │
│  │ Registry │  │ Servers  │  │  APIs    │                │
│  └──────────┘  └──────────┘  └──────────┘                │
│                      │                                       │
│                      ▼                                       │
│  通知層 (Notification Layer)                                 │
│  • Line Push                                                 │
│  • Email                                                     │
│  • Web Push                                                  │
│  • Voice (TTS)                                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

**文件版本**：v1.1  
**最後更新**：2026-01-17  
**更新內容**：
- ✅ 新增擴充性設計（工具註冊表、MCP Server、自訂 API）
- ✅ 新增語音整合設計（統一 Gateway、LiveKit 整合）
- ✅ 新增 JARVIS 光球介面設計（參考 06.JOBS_STYLE_AI_ASSISTANT_DESIGN.md）
- ✅ 更新實作優先順序（加入語音整合與擴充性實作）

**下一步**：開始實作 Phase 1 核心功能（包含 JARVIS 光球介面）
